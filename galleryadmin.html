<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Admin v2 | Face Sync (Smart & Progress)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://cdn.jsdelivr.net/npm/@vladmandic/face-api@1.7.4/dist/face-api.min.js"></script>
</head>
<body class="bg-slate-900 text-white min-h-screen p-6">
  <div class="max-w-4xl mx-auto">
    <h1 class="text-3xl font-bold mb-4 text-center">üß† Admin v2 ‚Äî Face Sync Dashboard (Smart)</h1>

    <!-- Control panel -->
    <div class="bg-slate-800 rounded-xl p-5 mb-4 shadow">
      <div class="flex flex-col md:flex-row md:items-center md:justify-between gap-4">
        <div>
          <p id="status" class="text-gray-300">‚è≥ Loading models...</p>
          <p id="lastSync" class="text-gray-400 text-sm mt-1">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏ã‡∏¥‡∏á‡∏Ñ‡πå</p>
        </div>

        <div class="flex gap-2 items-center">
          <label class="text-sm text-gray-300 mr-2">MIN FACE (px)</label>
          <input id="minFaceSize" type="number" value="50" min="20" max="1000" class="w-24 px-2 py-1 rounded bg-slate-700 text-white"/>
          <label class="ml-4 text-sm text-gray-300">Auto Sync</label>
          <input id="autoSyncToggle" type="checkbox" class="h-5 w-5 ml-2" />
          <label class="ml-2 text-sm text-gray-300">Interval (s)</label>
          <input id="autoInterval" type="number" value="60" min="10" step="5" class="w-20 px-2 py-1 rounded bg-slate-700 text-white ml-2"/>
        </div>
      </div>

      <div class="mt-4 flex gap-2">
        <button id="syncNow" class="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded">üîÅ Sync Now</button>
        <button id="stopAuto" class="bg-yellow-600 hover:bg-yellow-700 px-4 py-2 rounded">‚è∏Ô∏è Stop Auto</button>
        <button id="clearLog" class="bg-red-600 hover:bg-red-700 px-4 py-2 rounded">üßπ Clear Log</button>
      </div>
    </div>

    <!-- Progress / Stats -->
    <div class="bg-slate-800 rounded-xl p-5 mb-4 shadow">
      <div class="mb-3">
        <div class="flex justify-between">
          <div class="text-sm text-gray-300">Processed: <span id="processed">0</span>/<span id="total">0</span></div>
          <div class="text-sm text-gray-300">Elapsed: <span id="elapsed">0s</span></div>
        </div>
        <div class="w-full bg-slate-700 rounded h-4 mt-2 overflow-hidden">
          <div id="progressBar" class="h-4 bg-green-500 w-0 transition-all"></div>
        </div>
      </div>

      <div class="grid grid-cols-3 gap-3 text-center">
        <div class="bg-slate-700 p-3 rounded">
          <div class="text-sm text-gray-300">‚úÖ Success</div>
          <div id="countSuccess" class="text-2xl font-bold text-green-400">0</div>
        </div>
        <div class="bg-slate-700 p-3 rounded">
          <div class="text-sm text-gray-300">‚öôÔ∏è Skipped</div>
          <div id="countSkipped" class="text-2xl font-bold text-blue-300">0</div>
        </div>
        <div class="bg-slate-700 p-3 rounded">
          <div class="text-sm text-gray-300">‚ùå Failed</div>
          <div id="countFailed" class="text-2xl font-bold text-red-400">0</div>
        </div>
      </div>
    </div>

    <!-- Log -->
    <div class="bg-slate-800 rounded-xl p-4 shadow mb-6">
      <h2 class="text-lg font-semibold mb-2">üìú Log</h2>
      <div id="log" class="h-72 overflow-y-auto bg-slate-900/30 p-3 rounded text-xs font-mono"></div>
    </div>

    <!-- Footer / Help -->
    <div class="text-sm text-gray-400">
      <p>‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏: ‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏∞‡∏Ç‡πâ‡∏≤‡∏°‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏†‡∏≤‡∏û‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥ (jpg, jpeg, png, webp, gif) ‡πÅ‡∏•‡∏∞‡∏Ç‡πâ‡∏≤‡∏° `.emptyFolderPlaceholder`</p>
      <p class="mt-1">‡∏´‡∏≤‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏¢‡∏≠‡∏°‡∏£‡∏±‡∏ö‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏•‡πá‡∏Å ‡πÉ‡∏´‡πâ‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡πà‡∏≤ MIN FACE ‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡πà‡∏≤‡∏ï‡πà‡∏≥‡∏•‡∏á (‡πÄ‡∏ä‡πà‡∏ô 40 ‡∏´‡∏£‡∏∑‡∏≠ 30)</p>
    </div>
  </div>

  <script type="module">
    import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm'

    // -------------------------
    // CONFIG - ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì
    // -------------------------
    const SUPABASE_URL = "https://xjdjurdflowiwdxgkvfr.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InhqZGp1cmRmbG93aXdkeGdrdmZyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQzMDk5OTEsImV4cCI6MjA2OTg4NTk5MX0.QtWt1IrY1UYKmj0spL3T8CkaQh9wq2P-_4b6eWB3ics";
    const BUCKET = "gallery";

    const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    // -------------------------
    // DOM
    // -------------------------
    const statusEl = document.getElementById('status');
    const lastSyncEl = document.getElementById('lastSync');
    const syncNowBtn = document.getElementById('syncNow');
    const stopAutoBtn = document.getElementById('stopAuto');
    const clearLogBtn = document.getElementById('clearLog');
    const logEl = document.getElementById('log');

    const processedEl = document.getElementById('processed');
    const totalEl = document.getElementById('total');
    const progressBar = document.getElementById('progressBar');
    const elapsedEl = document.getElementById('elapsed');
    const minFaceSizeInput = document.getElementById('minFaceSize');
    const autoSyncToggle = document.getElementById('autoSyncToggle');
    const autoIntervalInput = document.getElementById('autoInterval');

    const countSuccessEl = document.getElementById('countSuccess');
    const countSkippedEl = document.getElementById('countSkipped');
    const countFailedEl = document.getElementById('countFailed');

    // -------------------------
    // state
    // -------------------------
    let isSyncing = false;
    let stopRequested = false;
    let autoSyncId = null;
    let stats = { success: 0, skipped: 0, failed: 0, processed: 0, total: 0 };
    let startTime = null;

    // -------------------------
    // helper log
    // -------------------------
    function log(type, text) {
      const time = new Date().toLocaleTimeString();
      const color = type === 'error' ? 'text-red-300' : type === 'warn' ? 'text-yellow-300' : 'text-green-300';
      const p = document.createElement('div');
      p.className = `${color} mb-1`;
      p.innerHTML = `<span class="text-gray-400">[${time}]</span> ${text}`;
      logEl.prepend(p);
    }

    function resetStats() {
      stats = { success: 0, skipped: 0, failed: 0, processed: 0, total: 0 };
      updateStatsUI();
    }

    function updateStatsUI() {
      countSuccessEl.textContent = stats.success;
      countSkippedEl.textContent = stats.skipped;
      countFailedEl.textContent = stats.failed;
      processedEl.textContent = stats.processed;
      totalEl.textContent = stats.total;
      const pct = stats.total ? Math.round((stats.processed / stats.total) * 100) : 0;
      progressBar.style.width = pct + '%';
    }

    function updateElapsed() {
      if (!startTime) { elapsedEl.textContent = '0s'; return; }
      const s = Math.floor((Date.now() - startTime) / 1000);
      elapsedEl.textContent = s + 's';
    }

    // -------------------------
    // face-api load
    // -------------------------
    async function loadModels() {
      statusEl.textContent = '‚è≥ ‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏• face-api...';
      const modelURL = 'https://cdn.jsdelivr.net/npm/@vladmandic/face-api@1.7.4/model/';
      await Promise.all([
        faceapi.nets.ssdMobilenetv1.loadFromUri(modelURL),
        faceapi.nets.faceLandmark68Net.loadFromUri(modelURL),
        faceapi.nets.faceRecognitionNet.loadFromUri(modelURL)
      ]);
      statusEl.textContent = '‚úÖ ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏ã‡∏¥‡∏á‡∏Ñ‡πå';
      log('info','‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô');
    }

    // -------------------------
    // list files recursive
    // -------------------------
    async function listRecursive(path = '') {
      const { data, error } = await supabase.storage.from(BUCKET).list(path, { limit: 1000 });
      if (error) {
        log('error', `Storage list error: ${error.message}`);
        return [];
      }
      let files = [];
      for (const item of data) {
        // item: {name, id, updated_at, created_at, last_accessed_at, metadata}
        // if it's a folder -> metadata is null (or absent) ; if file -> has metadata
        if (!item.metadata) {
          // skip system placeholders or dot-folders
          if (item.name && item.name.startsWith('.')) continue;
          const sub = await listRecursive(path ? `${path}/${item.name}` : item.name);
          files = files.concat(sub);
        } else {
          const fullPath = path ? `${path}/${item.name}` : item.name;
          files.push(fullPath);
        }
      }
      return files;
    }

    // -------------------------
    // normalize helper
    // -------------------------
    function normalize(desc) {
      const norm = Math.sqrt(desc.reduce((a,b)=>a+b*b,0));
      return desc.map(x => x / norm);
    }

    // -------------------------
    // validate image path
    // -------------------------
    function isImagePath(path) {
      if (!path) return false;
      // skip Supabase placeholder file
      if (path.includes('.emptyFolderPlaceholder')) return false;
      // basic extension check
      return !!path.match(/\.(jpg|jpeg|png|webp|gif)$/i);
    }

    // -------------------------
    // insert RPC wrapper
    // -------------------------
    async function insertFace(name, image_url, embedding) {
      // embedding should be array normalized
      const { error } = await supabase.rpc('insert_face_vector', {
        p_name: name,
        p_image_url: image_url,
        p_embedding: embedding
      });
      return error ? { ok: false, error } : { ok: true };
    }

    // -------------------------
    // main sync function
    // -------------------------
    async function syncGallery() {
      if (isSyncing) {
        log('warn', '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß - ‡∏£‡∏≠‡πÉ‡∏´‡πâ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏Å‡πà‡∏≠‡∏ô');
        return;
      }
      stopRequested = false;
      isSyncing = true;
      resetStats();
      startTime = Date.now();
      updateElapsed();
      statusEl.textContent = 'üîÑ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ã‡∏¥‡∏á‡∏Ñ‡πå...';

      try {
        const allFiles = await listRecursive('');
        // filter image files only
        const imageFiles = allFiles.filter(isImagePath);
        stats.total = imageFiles.length;
        updateStatsUI();

        if (stats.total === 0) {
          statusEl.textContent = '‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏†‡∏≤‡∏û‡πÉ‡∏ô Gallery';
          log('warn','‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏†‡∏≤‡∏û‡πÉ‡∏ô bucket');
          isSyncing = false;
          return;
        }

        log('info', `‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏• ${stats.total} ‡πÑ‡∏ü‡∏•‡πå`);

        for (let i=0; i<imageFiles.length; i++) {
          if (stopRequested) { log('warn','‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡∏ã‡∏¥‡∏á‡∏Ñ‡πå'); break; }
          const path = imageFiles[i];

          // update elapsed and progress
          updateElapsed();

          try {
            // skip non image again safety
            if (!isImagePath(path)) {
              stats.skipped++; stats.processed++;
              log('warn', `‡∏Ç‡πâ‡∏≤‡∏°‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏£‡∏π‡∏õ: ${path}`);
              updateStatsUI();
              continue;
            }

            // check exists in faces table
            const { data: exists, error: qerr } = await supabase.from('faces').select('id').eq('image_url', path).maybeSingle();
            if (qerr) {
              log('error', `DB check error ${path}: ${qerr.message}`);
              stats.failed++; stats.processed++; updateStatsUI();
              continue;
            }
            if (exists) {
              stats.skipped++; stats.processed++; updateStatsUI();
              log('info', `‡∏Ç‡πâ‡∏≤‡∏° (‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß): ${path}`);
              continue;
            }

            // fetch image via CDN url (public)
            const imgUrl = `${SUPABASE_URL}/storage/v1/object/public/${BUCKET}/${encodeURIComponent(path)}`;

            // use faceapi.fetchImage (handles CORS)
            let img;
            try {
              img = await faceapi.fetchImage(imgUrl);
            } catch (fe) {
              // if not image or fetch error
              log('error', `fetchImage failed: ${path} - ${fe.message || fe}`);
              stats.failed++; stats.processed++; updateStatsUI();
              continue;
            }

            // detect single face
            const det = await faceapi.detectSingleFace(img).withFaceLandmarks().withFaceDescriptor();
            if (!det) {
              stats.failed++; stats.processed++; updateStatsUI();
              log('warn', `‡∏ï‡∏£‡∏ß‡∏à‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤: ${path}`);
              continue;
            }

            // size check
            const minFaceSize = Number(minFaceSizeInput.value) || 50;
            if (det.detection.box.width < minFaceSize || det.detection.box.height < minFaceSize) {
              stats.failed++; stats.processed++; updateStatsUI();
              log('warn', `‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏•‡πá‡∏Å‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ: ${path}`);
              continue;
            }

            // create embedding
            const embedding = normalize(Array.from(det.descriptor));
            const name = path.split('/').pop().split('.').shift();

            // insert via RPC
            const res = await insertFace(name, path, embedding);
            if (!res.ok) {
              stats.failed++; stats.processed++; updateStatsUI();
              log('error', `‚ùå Error ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å ${path}: ${res.error.message}`);
            } else {
              stats.success++; stats.processed++; updateStatsUI();
              log('info', `‚úÖ ‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: ${path}`);
            }

          } catch (e) {
            stats.failed++; stats.processed++; updateStatsUI();
            log('error', `Exception ${path}: ${e.message || e}`);
          }
        } // end for

        const now = new Date().toLocaleString();
        lastSyncEl.textContent = `‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î: ${now}`;
        statusEl.textContent = `‚úÖ ‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡πÄ‡∏™‡∏£‡πá‡∏à (‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ${stats.success}, ‡∏Ç‡πâ‡∏≤‡∏° ${stats.skipped}, ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß ${stats.failed})`;
        log('info', `‡∏™‡∏£‡∏∏‡∏õ: ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ${stats.success}, ‡∏Ç‡πâ‡∏≤‡∏° ${stats.skipped}, ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß ${stats.failed}`);

      } catch (err) {
        log('error', `Critical sync error: ${err.message || err}`);
        statusEl.textContent = '‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ã‡∏¥‡∏á‡∏Ñ‡πå';
      } finally {
        isSyncing = false;
      }
    }

    // -------------------------
    // auto sync control
    // -------------------------
    function startAutoSync() {
      stopAuto(); // clear existing
      const intervalSec = Math.max(10, Number(autoIntervalInput.value) || 60);
      autoSyncId = setInterval(() => {
        if (!isSyncing) syncGallery();
      }, intervalSec * 1000);
      autoSyncToggle.checked = true;
      log('info', `Auto Sync ‡πÄ‡∏£‡∏¥‡πà‡∏° (‡∏ó‡∏∏‡∏Å ${intervalSec}s)`);
    }

    function stopAuto() {
      if (autoSyncId) {
        clearInterval(autoSyncId);
        autoSyncId = null;
      }
      autoSyncToggle.checked = false;
      log('info', 'Auto Sync ‡∏´‡∏¢‡∏∏‡∏î‡πÅ‡∏•‡πâ‡∏ß');
    }

    // -------------------------
    // events
    // -------------------------
    syncNowBtn.addEventListener('click', () => {
      syncGallery();
    });
    stopAutoBtn.addEventListener('click', () => {
      stopRequested = true;
      stopAuto();
    });
    clearLogBtn.addEventListener('click', () => {
      logEl.innerHTML = '';
      resetStats();
    });

    autoSyncToggle.addEventListener('change', (e) => {
      if (e.target.checked) startAutoSync(); else stopAuto();
    });

    // -------------------------
    // init
    // -------------------------
    window.addEventListener('DOMContentLoaded', async () => {
      await loadModels();
      // optionally start auto if toggle is on
      if (autoSyncToggle.checked) startAutoSync();
      // small timer to update elapsed display
      setInterval(updateElapsed, 1000);
    });

  </script>
</body>
</html>
