<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Admin v3.0 UltraStable | Smart Face Sync Dashboard</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://cdn.jsdelivr.net/npm/@vladmandic/face-api@1.7.4/dist/face-api.min.js"></script>
</head>

<body class="bg-slate-900 text-white min-h-screen p-6">
  <div class="max-w-6xl mx-auto">
    <h1 class="text-3xl font-bold mb-4 text-center">
      üß† Admin v3.0 ‚Äî Smart Face Sync Dashboard (UltraStable)
    </h1>

    <!-- üß© Control Panel -->
    <div class="bg-slate-800 rounded-xl p-5 mb-4 shadow">
      <div class="flex flex-wrap gap-3 items-center justify-between">
        <div>
          <p id="status" class="text-gray-300">‚è≥ Loading models...</p>
          <p id="lastSync" class="text-gray-400 text-sm mt-1">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏ã‡∏¥‡∏á‡∏Ñ‡πå</p>
        </div>
        <div class="flex flex-wrap gap-3 items-center">
          <label class="text-sm text-gray-300">MIN FACE</label>
          <input id="minFaceSize" type="number" value="50" class="w-20 px-2 py-1 rounded bg-slate-700 text-white"/>
          <label class="text-sm text-gray-300">Rate Limit</label>
          <input id="rateLimit" type="number" value="5" class="w-20 px-2 py-1 rounded bg-slate-700 text-white"/>
          <label class="text-sm text-gray-300">Delay (ms)</label>
          <input id="delayMs" type="number" value="200" class="w-24 px-2 py-1 rounded bg-slate-700 text-white"/>
          <label class="text-sm text-gray-300">Auto Sync</label>
          <input id="autoSyncToggle" type="checkbox" class="h-5 w-5"/>
          <label class="text-sm text-gray-300">Interval (s)</label>
          <input id="autoInterval" type="number" value="60" class="w-20 px-2 py-1 rounded bg-slate-700 text-white"/>
        </div>
      </div>

      <div class="mt-4 flex flex-wrap gap-2">
        <button id="syncNow" class="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded">üîÅ Sync Now</button>
        <button id="stopAuto" class="bg-yellow-600 hover:bg-yellow-700 px-4 py-2 rounded">‚è∏Ô∏è Stop Auto</button>
        <button id="clearLog" class="bg-red-600 hover:bg-red-700 px-4 py-2 rounded">üßπ Clear Log</button>
        <button id="clearCache" class="bg-gray-600 hover:bg-gray-700 px-4 py-2 rounded">üóëÔ∏è Clear Cache</button>
      </div>
    </div>

    <!-- Progress -->
    <div class="bg-slate-800 rounded-xl p-5 mb-4 shadow">
      <div class="flex justify-between text-sm text-gray-300 mb-2">
        <div>Processed: <span id="processed">0</span>/<span id="total">0</span></div>
        <div>Elapsed: <span id="elapsed">0s</span></div>
      </div>
      <div class="w-full bg-slate-700 rounded h-4 mb-3 overflow-hidden">
        <div id="progressBar" class="h-4 bg-green-500 w-0 transition-all"></div>
      </div>
      <div class="grid grid-cols-3 gap-3 text-center">
        <div class="bg-slate-700 p-3 rounded"><div>‚úÖ Success</div><div id="countSuccess" class="text-2xl font-bold text-green-400">0</div></div>
        <div class="bg-slate-700 p-3 rounded"><div>‚öôÔ∏è Skipped</div><div id="countSkipped" class="text-2xl font-bold text-blue-300">0</div></div>
        <div class="bg-slate-700 p-3 rounded"><div>‚ùå Failed</div><div id="countFailed" class="text-2xl font-bold text-red-400">0</div></div>
      </div>
    </div>

    <!-- Log -->
    <div class="bg-slate-800 rounded-xl p-4 shadow mb-6">
      <h2 class="text-lg font-semibold mb-2">üìú Log</h2>
      <div id="log" class="h-72 overflow-y-auto bg-slate-900/30 p-3 rounded text-xs font-mono"></div>
    </div>

    <!-- Failed Preview -->
    <div class="bg-slate-800 rounded-xl p-4 shadow">
      <h2 class="text-lg font-semibold mb-3">‚ùå ‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏ß‡∏à‡πÑ‡∏°‡πà‡∏ú‡πà‡∏≤‡∏ô</h2>
      <div id="failedGrid" class="grid grid-cols-2 md:grid-cols-4 gap-3"></div>
    </div>
  </div>

<script type="module">
import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm";
const SUPABASE_URL = "https://xjdjurdflowiwdxgkvfr.supabase.co";
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InhqZGp1cmRmbG93aXdkeGdrdmZyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQzMDk5OTEsImV4cCI6MjA2OTg4NTk5MX0.QtWt1IrY1UYKmj0spL3T8CkaQh9wq2P-_4b6eWB3ics";
const BUCKET = "gallery";
const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

const $ = id => document.getElementById(id);
const delay = ms => new Promise(r => setTimeout(r, ms));
const log = (type, text) => {
  const time = new Date().toLocaleTimeString();
  const color = type === "error" ? "text-red-300" : type === "warn" ? "text-yellow-300" : "text-green-300";
  const div = document.createElement("div");
  div.className = `${color} mb-1`;
  div.innerHTML = `<span class="text-gray-400">[${time}]</span> ${text}`;
  $("log").prepend(div);
};

let isSyncing = false, stopRequested = false, startTime = null;
let stats = { success: 0, skipped: 0, failed: 0, processed: 0, total: 0 };
const processedSet = new Set();
const failedImages = new Map();

/* ‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏• */
async function loadModels() {
  $("status").textContent = "‚è≥ ‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏•...";
  const modelURL = "https://cdn.jsdelivr.net/npm/@vladmandic/face-api@1.7.4/model/";
  await Promise.all([
    faceapi.nets.ssdMobilenetv1.loadFromUri(modelURL),
    faceapi.nets.tinyFaceDetector.loadFromUri(modelURL),
    faceapi.nets.faceLandmark68Net.loadFromUri(modelURL),
    faceapi.nets.faceRecognitionNet.loadFromUri(modelURL)
  ]);
  $("status").textContent = "‚úÖ ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏ã‡∏¥‡∏á‡∏Ñ‡πå";
  log("info", "‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏Ñ‡∏£‡∏ö‡πÅ‡∏•‡πâ‡∏ß");
}

/* ‡πÇ‡∏´‡∏•‡∏î‡∏£‡∏π‡∏õ robust */
async function fetchImageRobust(url) {
  try {
    const resp = await fetch(url, { cache: "no-store" });
    const blob = await resp.blob();
    return await blobToImage(blob);
  } catch {
    return await faceapi.fetchImage(url);
  }
}

function blobToImage(blob) {
  return new Promise((res, rej) => {
    const url = URL.createObjectURL(blob);
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.onload = () => { URL.revokeObjectURL(url); res(img); };
    img.onerror = () => rej(new Error("load error"));
    img.src = url;
  });
}

/* ‡πÅ‡∏õ‡∏•‡∏á / ‡∏´‡∏°‡∏∏‡∏ô‡∏†‡∏≤‡∏û */
async function transformImage(img, { angle = 0, scale = 1 } = {}) {
  const rad = (angle * Math.PI) / 180;
  const w = img.width, h = img.height;
  const canvas = document.createElement("canvas");
  if (angle % 180 === 0) { canvas.width = w; canvas.height = h; }
  else { canvas.width = h; canvas.height = w; }
  const ctx = canvas.getContext("2d");
  ctx.translate(canvas.width / 2, canvas.height / 2);
  ctx.rotate(rad);
  ctx.scale(scale, scale);
  ctx.drawImage(img, -w / 2, -h / 2);
  const blob = await new Promise(r => canvas.toBlob(r, "image/jpeg", 0.95));
  return await blobToImage(blob);
}

/* ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏´‡∏°‡∏∏‡∏ô + multi-scale hybrid */
async function detectFaceWithRotationSupport(imgUrl, minFaceSize = 50) {
  const img = await fetchImageRobust(imgUrl);

  // üî∏ ‡∏•‡∏≠‡∏á‡∏ï‡∏£‡∏ß‡∏à‡∏ó‡∏±‡πâ‡∏á ssd ‡πÅ‡∏•‡∏∞ tiny ‡πÉ‡∏ô‡∏£‡∏≠‡∏ö‡πÅ‡∏£‡∏Å
  let det = await detectFaceMulti(img, { minFaceSize });
  if (det) return det;

  // üî∏ ‡∏•‡∏≠‡∏á‡∏´‡∏°‡∏∏‡∏ô‡∏†‡∏≤‡∏û 90 / 270 ‡∏≠‡∏á‡∏®‡∏≤
  for (const angle of [90, 270]) {
    const rImg = await transformImage(img, { angle });
    det = await detectFaceMulti(rImg, { minFaceSize });
    if (det) return det;
  }

  // üî∏ ‡∏•‡∏≠‡∏á upscale 1.5x (‡∏ä‡πà‡∏ß‡∏¢‡∏à‡∏±‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏•‡πá‡∏Å)
  const upImg = await transformImage(img, { angle: 0, scale: 1.5 });
  det = await detectFaceMulti(upImg, { minFaceSize: minFaceSize * 0.8 });
  if (det) return det;

  // üî∏ ‡∏•‡∏≠‡∏á‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢: detectAllFaces ‡πÅ‡∏•‡πâ‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà‡πÉ‡∏´‡∏ç‡πà‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
  const all = await faceapi.detectAllFaces(img, new faceapi.SsdMobilenetv1Options({ minConfidence: 0.2 }))
    .withFaceLandmarks().withFaceDescriptors();
  if (all && all.length) {
    const largest = all.reduce((a, b) =>
      (b.detection.box.width * b.detection.box.height > a.detection.box.width * a.detection.box.height ? b : a)
    );
    return largest;
  }

  return null;
}

/* ‡∏ï‡∏£‡∏ß‡∏à‡∏´‡∏•‡∏≤‡∏¢ scale ‡πÅ‡∏•‡∏∞ hybrid ssd + tiny */
async function detectFaceMulti(img, opts = {}) {
  const minFaceSize = opts.minFaceSize || 50;

  // üß† ‡∏•‡∏≠‡∏á ssd ‡∏Å‡πà‡∏≠‡∏ô (‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏™‡∏∏‡∏î)
  try {
    const detSSD = await faceapi.detectSingleFace(img, new faceapi.SsdMobilenetv1Options({ minConfidence: 0.2 }))
      .withFaceLandmarks().withFaceDescriptor();
    if (detSSD && (detSSD.detection.box.width >= minFaceSize || detSSD.detection.box.height >= minFaceSize)) {
      return detSSD;
    }
  } catch (e) {
    console.warn("SSD failed:", e.message);
  }

  // üîπ ‡∏ñ‡πâ‡∏≤ ssd ‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠ ‡πÉ‡∏ä‡πâ tiny ‡∏´‡∏•‡∏≤‡∏¢ inputSize
  const tinyConfigs = [
    { inputSize: 512, scoreThreshold: 0.35 },
    { inputSize: 416, scoreThreshold: 0.3 },
    { inputSize: 320, scoreThreshold: 0.25 }
  ];
  for (const cfg of tinyConfigs) {
    try {
      const detTiny = await faceapi.detectSingleFace(img, new faceapi.TinyFaceDetectorOptions(cfg))
        .withFaceLandmarks().withFaceDescriptor();
      if (detTiny && (detTiny.detection.box.width >= minFaceSize || detTiny.detection.box.height >= minFaceSize)) {
        return detTiny;
      }
    } catch (e) {
      console.warn("Tiny failed:", e.message);
    }
  }

  return null;
}


/* ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥ */
function updateStats() {
  $("countSuccess").textContent = stats.success;
  $("countSkipped").textContent = stats.skipped;
  $("countFailed").textContent = stats.failed;
  $("processed").textContent = stats.processed;
  $("total").textContent = stats.total;
  $("progressBar").style.width = (stats.total ? Math.round((stats.processed / stats.total) * 100) : 0) + "%";
}

/* ‡πÅ‡∏Ñ‡∏ä */
const loadCache = () => JSON.parse(localStorage.getItem("gallery-cache") || "{}");
const saveCache = c => localStorage.setItem("gallery-cache", JSON.stringify(c));
const clearCache = () => { localStorage.removeItem("gallery-cache"); log("info", "üßπ ‡∏•‡πâ‡∏≤‡∏á cache ‡πÅ‡∏•‡πâ‡∏ß"); };

/* Preview fail */
function addFailedPreview(path, imgUrl, reason) {
  if (failedImages.has(path)) return;
  failedImages.set(path, true);
  const div = document.createElement("div");
  div.className = "bg-slate-700 p-2 rounded relative";
  div.innerHTML = `
    <img src="${imgUrl}" class="rounded w-full object-cover h-40"/>
    <p class="text-xs text-center mt-1 text-red-300">${reason}</p>
    <button class="absolute bottom-2 right-2 bg-blue-600 hover:bg-blue-700 text-xs px-2 py-1 rounded retry-btn">Retry</button>
  `;
  $("failedGrid").appendChild(div);
  div.querySelector(".retry-btn").onclick = async () => {
    div.style.opacity = "0.5";
    await handleSync(path, { [path]: { updated_at: new Date().toISOString() } }, loadCache(), 0, true);
    div.remove();
    failedImages.delete(path);
  };
}

/* handleSync (‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ï‡∏£‡∏ß‡∏à‡πÅ‡∏ö‡∏ö‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î) */
// async function handleSync(path, map, cache, attempt = 0, singleRetry = false) {
//   const cacheT = cache[path], updated = map[path].updated_at;
//   if (!singleRetry && cacheT && updated <= cacheT) {
//     stats.skipped++; if (!processedSet.has(path)) { processedSet.add(path); stats.processed++; } updateStats(); return;
//   }
//   try {
//     const { data: exists } = await supabase.from("faces").select("id").eq("image_url", path).maybeSingle();
//     if (exists) { stats.skipped++; if (!processedSet.has(path)) { processedSet.add(path); stats.processed++; } cache[path] = updated; saveCache(cache); updateStats(); return; }

//     const imgUrl = `${SUPABASE_URL}/storage/v1/object/public/${BUCKET}/${encodeURIComponent(path)}`;
//     const minFace = Number($("minFaceSize").value) || 50;
//     const det = await detectFaceWithRotationSupport(imgUrl, minFace);
//     if (!det) throw new Error("‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤");

//     const emb = Array.from(det.descriptor);
//     const name = path.split("/").pop().split(".").shift();
//     const { error } = await supabase.rpc("insert_face_vector", { p_name: name, p_image_url: path, p_embedding: emb });
//     if (error) throw new Error(error.message);

//     stats.success++; cache[path] = updated; saveCache(cache); log("info", `‚úÖ ${path}`);
//   } catch (err) {
//     if (attempt < 2 && !singleRetry) { await delay(500); return await handleSync(path, map, cache, attempt + 1); }
//     stats.failed++; log("error", `‚ùå ${path}: ${err.message}`);
//     const imgUrl = `${SUPABASE_URL}/storage/v1/object/public/${BUCKET}/${encodeURIComponent(path)}`;
//     addFailedPreview(path, imgUrl, err.message);
//   } finally {
//     if (!processedSet.has(path)) { processedSet.add(path); stats.processed++; updateStats(); }
//   }
// }
  /* üß† Hybrid Face Sync Mode ‚Äî ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏´‡∏•‡∏≤‡∏¢‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡πÉ‡∏ô‡∏†‡∏≤‡∏û‡πÄ‡∏î‡∏µ‡∏¢‡∏ß */
async function handleSync(path, map, cache, attempt = 0, singleRetry = false) {
  const cacheT = cache[path], updated = map[path].updated_at;
  if (!singleRetry && cacheT && updated <= cacheT) {
    stats.skipped++;
    if(!processedSet.has(path)){processedSet.add(path);stats.processed++;}
    updateStats(); 
    return;
  }

  try {
    const { data: exists } = await supabase.from("faces").select("id").eq("image_url", path).maybeSingle();
    if (exists) {
      stats.skipped++;
      if(!processedSet.has(path)){processedSet.add(path);stats.processed++;}
      cache[path] = updated; saveCache(cache); updateStats();
      return;
    }

    const imgUrl = `${SUPABASE_URL}/storage/v1/object/public/${BUCKET}/${encodeURIComponent(path)}`;
    const img = await faceapi.fetchImage(imgUrl);

    // üîç ‡∏ï‡∏£‡∏ß‡∏à‡∏´‡∏•‡∏≤‡∏¢‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡∏Å‡πà‡∏≠‡∏ô
    let detections = await faceapi
      .detectAllFaces(img, new faceapi.SsdMobilenetv1Options({ minConfidence: 0.2 }))
      .withFaceLandmarks().withFaceDescriptors();

    // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠ ‚Üí fallback ‡πÇ‡∏´‡∏°‡∏î‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î (smart)
    if (!detections || detections.length === 0) {
      detections = [];
      const single = await detectFaceWithRotationSupport(imgUrl, Number($("minFaceSize").value));
      if (single) detections.push(single);
    }

    if (!detections || detections.length === 0) throw new Error("‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡πÉ‡∏ô‡∏†‡∏≤‡∏û");

    const minFace = Number($("minFaceSize").value) || 50;
    const validFaces = detections.filter(d =>
      d.detection.box.width >= minFace && d.detection.box.height >= minFace
    );

    if (validFaces.length === 0) throw new Error("‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏•‡πá‡∏Å‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î");

    // ‚úÖ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ó‡∏∏‡∏Å‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏ß‡∏à‡πÄ‡∏à‡∏≠
    // for (let i = 0; i < validFaces.length; i++) {
    //   const det = validFaces[i];
    //   const emb = Array.from(det.descriptor);
    //   const name = `${path.split("/").pop().split(".").shift()}#${i+1}`;
    //   const { error } = await supabase.rpc("insert_face_vector", {
    //     p_name: name,
    //     p_image_url: path,
    //     p_embedding: emb
    //   });
    //   if (error) console.warn("‚ö†Ô∏è insert_face_vector error:", error.message);
    // }
    // ===============================
// ‚úÖ ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡∏´‡∏•‡∏±‡∏Å (‡πÉ‡∏´‡∏ç‡πà‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î)
// ===============================
const area = d => d.detection.box.width * d.detection.box.height;

const mainFace = validFaces.reduce((a, b) =>
  area(b) > area(a) ? b : a
);

const det = mainFace;

const emb = Array.from(det.descriptor);
const name = path.split("/").pop().split(".").shift();

await supabase.rpc("insert_face_vector", {
  p_name: name,
  p_image_url: path,
  p_embedding: emb
});


    stats.success++;
    cache[path] = updated;
    saveCache(cache);
    log("info", `‚úÖ ${path} (‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà‡πÄ‡∏à‡∏≠: ${validFaces.length})`);

  } catch (err) {
    if (attempt < 2 && !singleRetry) {
      log("warn", `Retry ${attempt + 1}/3: ${path} (${err.message})`);
      await delay(500);
      return await handleSync(path, map, cache, attempt + 1);
    } else {
      log("error", `‚ùå ${path}: ${err.message}`);
      stats.failed++;
      const imgUrl = `${SUPABASE_URL}/storage/v1/object/public/${BUCKET}/${encodeURIComponent(path)}`;
      addFailedPreview(path, imgUrl, err.message);
    }
  } finally {
    if (!processedSet.has(path)) {
      processedSet.add(path);
      stats.processed++;
      updateStats();
    }
  }
}


/* listRecursive */
async function listRecursive(path = "", map = {}) {
  const limit = 1000; let offset = 0;
  while (true) {
    const { data } = await supabase.storage.from(BUCKET).list(path, { limit, offset });
    if (!data || data.length === 0) break;
    for (const item of data) {
      if (!item.metadata) await listRecursive(path ? `${path}/${item.name}` : item.name, map);
      else map[path ? `${path}/${item.name}` : item.name] = { updated_at: item.updated_at };
    }
    if (data.length < limit) break;
    offset += limit; await delay(100);
  }
  return map;
}

/* syncGallery */
async function syncGallery() {
  if (isSyncing) return log("warn", "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß");
  stopRequested = false; isSyncing = true;
  stats = { success: 0, skipped: 0, failed: 0, processed: 0, total: 0 };
  processedSet.clear(); updateStats(); startTime = Date.now(); $("status").textContent = "üîÑ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ã‡∏¥‡∏á‡∏Ñ‡πå...";
  $("failedGrid").innerHTML = "";
  const map = await listRecursive("");
  const files = Object.keys(map).filter(p => p.match(/\.(jpg|jpeg|png|webp|gif)$/i));
  const cache = loadCache(); stats.total = files.length; updateStats();
  const limit = Number($("rateLimit").value) || 5, delayMs = Number($("delayMs").value) || 200;
  await Promise.all(Array.from({ length: limit }, async (_, w) => {
    for (let i = w; i < files.length && !stopRequested; i += limit) {
      await handleSync(files[i], map, cache);
      if (delayMs) await delay(delayMs);
    }
  }));
  $("status").textContent = `‚úÖ ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô (‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ${stats.success}, ‡∏Ç‡πâ‡∏≤‡∏° ${stats.skipped}, ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß ${stats.failed})`;
}

/* ‡∏õ‡∏∏‡πà‡∏° */
$("syncNow").onclick = syncGallery;
$("stopAuto").onclick = () => { stopRequested = true; log("warn", "‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡πÅ‡∏•‡πâ‡∏ß"); };
$("clearLog").onclick = () => { $("log").innerHTML = ""; stats = { success: 0, skipped: 0, failed: 0, processed: 0, total: 0 }; updateStats(); };
$("clearCache").onclick = clearCache;

let autoSyncId = null;
$("autoSyncToggle").onchange = e => {
  if (e.target.checked) autoSyncId = setInterval(syncGallery, Number($("autoInterval").value) * 1000);
  else clearInterval(autoSyncId);
};

setInterval(() => { if (startTime) $("elapsed").textContent = Math.floor((Date.now() - startTime) / 1000) + "s"; }, 1000);
window.addEventListener("DOMContentLoaded", loadModels);
</script>
</body>
</html>
