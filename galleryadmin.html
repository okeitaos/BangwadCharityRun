<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Admin v2.7.3 | Face Sync (Smart Detect+)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://cdn.jsdelivr.net/npm/@vladmandic/face-api@1.7.4/dist/face-api.min.js"></script>
</head>
<body class="bg-slate-900 text-white min-h-screen p-6">
  <div class="max-w-6xl mx-auto">
    <h1 class="text-3xl font-bold mb-4 text-center">üß† Admin v2.7.3 ‚Äî Smart Face Sync Dashboard</h1>

    <!-- Control Panel -->
    <div class="bg-slate-800 rounded-xl p-5 mb-4 shadow">
      <div class="flex flex-wrap gap-3 items-center justify-between">
        <div>
          <p id="status" class="text-gray-300">‚è≥ Loading models...</p>
          <p id="lastSync" class="text-gray-400 text-sm mt-1">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏ã‡∏¥‡∏á‡∏Ñ‡πå</p>
        </div>
        <div class="flex flex-wrap gap-3 items-center">
          <label class="text-sm text-gray-300">MIN FACE</label>
          <input id="minFaceSize" type="number" value="50" class="w-20 px-2 py-1 rounded bg-slate-700 text-white"/>
          <label class="text-sm text-gray-300">Rate Limit</label>
          <input id="rateLimit" type="number" value="5" class="w-20 px-2 py-1 rounded bg-slate-700 text-white"/>
          <label class="text-sm text-gray-300">Delay (ms)</label>
          <input id="delayMs" type="number" value="200" class="w-24 px-2 py-1 rounded bg-slate-700 text-white"/>
          <label class="text-sm text-gray-300">Auto Sync</label>
          <input id="autoSyncToggle" type="checkbox" class="h-5 w-5"/>
          <label class="text-sm text-gray-300">Interval (s)</label>
          <input id="autoInterval" type="number" value="60" class="w-20 px-2 py-1 rounded bg-slate-700 text-white"/>
        </div>
      </div>

      <div class="mt-4 flex flex-wrap gap-2">
        <button id="syncNow" class="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded">üîÅ Sync Now</button>
        <button id="stopAuto" class="bg-yellow-600 hover:bg-yellow-700 px-4 py-2 rounded">‚è∏Ô∏è Stop Auto</button>
        <button id="clearLog" class="bg-red-600 hover:bg-red-700 px-4 py-2 rounded">üßπ Clear Log</button>
        <button id="clearCache" class="bg-gray-600 hover:bg-gray-700 px-4 py-2 rounded">üóëÔ∏è Clear Cache</button>
      </div>
    </div>

    <!-- Progress -->
    <div class="bg-slate-800 rounded-xl p-5 mb-4 shadow">
      <div class="flex justify-between text-sm text-gray-300 mb-2">
        <div>Processed: <span id="processed">0</span>/<span id="total">0</span></div>
        <div>Elapsed: <span id="elapsed">0s</span></div>
      </div>
      <div class="w-full bg-slate-700 rounded h-4 mb-3 overflow-hidden">
        <div id="progressBar" class="h-4 bg-green-500 w-0 transition-all"></div>
      </div>
      <div class="grid grid-cols-3 gap-3 text-center">
        <div class="bg-slate-700 p-3 rounded"><div>‚úÖ Success</div><div id="countSuccess" class="text-2xl font-bold text-green-400">0</div></div>
        <div class="bg-slate-700 p-3 rounded"><div>‚öôÔ∏è Skipped</div><div id="countSkipped" class="text-2xl font-bold text-blue-300">0</div></div>
        <div class="bg-slate-700 p-3 rounded"><div>‚ùå Failed</div><div id="countFailed" class="text-2xl font-bold text-red-400">0</div></div>
      </div>
    </div>

    <!-- Log -->
    <div class="bg-slate-800 rounded-xl p-4 shadow mb-6">
      <h2 class="text-lg font-semibold mb-2">üìú Log</h2>
      <div id="log" class="h-72 overflow-y-auto bg-slate-900/30 p-3 rounded text-xs font-mono"></div>
    </div>

    <!-- Failed Preview -->
    <div class="bg-slate-800 rounded-xl p-4 shadow">
      <h2 class="text-lg font-semibold mb-3">‚ùå ‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏ß‡∏à‡πÑ‡∏°‡πà‡∏ú‡πà‡∏≤‡∏ô</h2>
      <div id="failedGrid" class="grid grid-cols-2 md:grid-cols-4 gap-3"></div>
    </div>
  </div>

  <script type="module">
    import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm";
    const SUPABASE_URL = "https://xjdjurdflowiwdxgkvfr.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InhqZGp1cmRmbG93aXdkeGdrdmZyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQzMDk5OTEsImV4cCI6MjA2OTg4NTk5MX0.QtWt1IrY1UYKmj0spL3T8CkaQh9wq2P-_4b6eWB3ics";
    const BUCKET = "gallery";
    const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    const $ = id => document.getElementById(id);
    const delay = ms => new Promise(r => setTimeout(r, ms));

    const log = (type, text) => {
      const time = new Date().toLocaleTimeString();
      const color = type === "error" ? "text-red-300" : type === "warn" ? "text-yellow-300" : "text-green-300";
      const div = document.createElement("div");
      div.className = `${color} mb-1`;
      div.innerHTML = `<span class="text-gray-400">[${time}]</span> ${text}`;
      $("log").prepend(div);
    };

    let isSyncing = false, stopRequested = false, autoSyncId = null, startTime = null;
    let stats = { success: 0, skipped: 0, failed: 0, processed: 0, total: 0 };
    const processedSet = new Set();
    const failedImages = new Map();

    /* üìä ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡πÅ‡∏•‡∏∞ Progress Bar */
    function updateStats() {
      $("countSuccess").textContent = stats.success;
      $("countSkipped").textContent = stats.skipped;
      $("countFailed").textContent = stats.failed;
      $("processed").textContent = stats.processed;
      $("total").textContent = stats.total;
      const percent = stats.total ? Math.round((stats.processed / stats.total) * 100) : 0;
      $("progressBar").style.width = percent + "%";
    }

    const loadCache = () => JSON.parse(localStorage.getItem("gallery-cache") || "{}");
    const saveCache = c => localStorage.setItem("gallery-cache", JSON.stringify(c));

    async function checkAPIKey() {
      try {
        const { error } = await supabase.from("faces").select("id").limit(1);
        if (error) throw error;
        log("info", "‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏µ‡∏¢‡πå Supabase ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô");
      } catch (e) {
        log("error", "‚ùå Invalid API key: " + e.message);
        $("status").textContent = "‚ùå Invalid API key";
        throw e;
      }
    }

    async function loadModels() {
      $("status").textContent = "‚è≥ ‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏•...";
      const modelURL = "https://cdn.jsdelivr.net/npm/@vladmandic/face-api@1.7.4/model/";
      await Promise.all([
        faceapi.nets.ssdMobilenetv1.loadFromUri(modelURL),
        faceapi.nets.tinyFaceDetector.loadFromUri(modelURL),
        faceapi.nets.faceLandmark68Net.loadFromUri(modelURL),
        faceapi.nets.faceRecognitionNet.loadFromUri(modelURL)
      ]);
      $("status").textContent = "‚úÖ ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏ã‡∏¥‡∏á‡∏Ñ‡πå";
      log("info", "üì¶ ‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏Ñ‡∏£‡∏ö‡πÅ‡∏•‡πâ‡∏ß");
    }

async function detectFaceSmart(img, retry = 0) {
  const rotations = [0, 90, 180, 270]; // ‡∏´‡∏°‡∏∏‡∏ô 4 ‡∏°‡∏∏‡∏°
  let bestDetection = null;
  let bestScore = 0;

  try {
    for (const angle of rotations) {
      const rotatedImg = angle ? await rotateImage(img, angle) : img;

      // 1Ô∏è‚É£ ‡∏ï‡∏£‡∏ß‡∏à‡∏î‡πâ‡∏ß‡∏¢ SSD (‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏™‡∏∏‡∏î)
      let detections = await faceapi
        .detectAllFaces(rotatedImg, new faceapi.SsdMobilenetv1Options({ minConfidence: 0.25 }))
        .withFaceLandmarks()
        .withFaceDescriptors();

      // 2Ô∏è‚É£ ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠ ‚Üí TinyFaceDetector (‡πÄ‡∏£‡πá‡∏ß‡∏Å‡∏ß‡πà‡∏≤)
      if (!detections.length) {
        detections = await faceapi
          .detectAllFaces(rotatedImg, new faceapi.TinyFaceDetectorOptions({
            inputSize: 640,
            scoreThreshold: 0.25
          }))
          .withFaceLandmarks()
          .withFaceDescriptors();
      }

      // 3Ô∏è‚É£ ‡∏ñ‡πâ‡∏≤‡πÄ‡∏à‡∏≠ ‚Üí ‡πÄ‡∏Å‡πá‡∏ö‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î
      for (const det of detections) {
        if (det.detection.score > bestScore) {
          bestDetection = det;
          bestScore = det.detection.score;
        }
      }

      // 4Ô∏è‚É£ log ‡∏ú‡∏•
      if (detections.length) {
        log("info", `üëÅÔ∏è ‡∏ï‡∏£‡∏ß‡∏à‡∏û‡∏ö ${detections.length} ‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡πÉ‡∏ô‡∏°‡∏∏‡∏° ${angle}¬∞ (‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î ${bestScore.toFixed(2)})`);
      }
    }

    // 5Ô∏è‚É£ ‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠ ‚Üí crop ‡∏ã‡∏µ‡∏Å‡∏ã‡πâ‡∏≤‡∏¢/‡∏Ç‡∏ß‡∏≤ ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏†‡∏≤‡∏û‡πÅ‡∏ô‡∏ß‡∏ô‡∏≠‡∏ô
    if (!bestDetection && img.width > img.height) {
      const halfW = img.width / 2;
      const leftCrop = await cropImage(img, 0, 0, halfW, img.height);
      const rightCrop = await cropImage(img, halfW, 0, halfW, img.height);

      for (const side of [leftCrop, rightCrop]) {
        const det = await faceapi
          .detectSingleFace(side, new faceapi.SsdMobilenetv1Options({ minConfidence: 0.2 }))
          .withFaceLandmarks()
          .withFaceDescriptor();
        if (det && det.detection.score > bestScore) {
          bestDetection = det;
          bestScore = det.detection.score;
        }
      }
      if (bestDetection) log("info", `üì∏ ‡∏ï‡∏£‡∏ß‡∏à‡πÄ‡∏à‡∏≠‡∏à‡∏≤‡∏Å crop ‡∏ã‡∏µ‡∏Å (${bestScore.toFixed(2)})`);
    }

    if (!bestDetection && retry < 2) {
      await delay(500);
      return await detectFaceSmart(img, retry + 1);
    }

    if (bestDetection) {
      const { box, score } = bestDetection.detection;
      log("info", `‚úÖ ‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡∏´‡∏•‡∏±‡∏Å (confidence=${score.toFixed(2)}, ${Math.round(box.width)}x${Math.round(box.height)})`);
      return bestDetection;
    } else {
      log("warn", "‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡πÅ‡∏°‡πâ‡∏™‡πÅ‡∏Å‡∏ô‡∏ó‡∏±‡πà‡∏ß‡∏ó‡∏±‡πâ‡∏á‡∏†‡∏≤‡∏û‡∏ó‡∏∏‡∏Å‡∏°‡∏∏‡∏°");
      return null;
    }

  } catch (e) {
    if (retry < 2) {
      await delay(500);
      return await detectFaceSmart(img, retry + 1);
    } else {
      log("error", "‚ö†Ô∏è ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß: " + e.message);
      return null;
    }
  }
}

/* üåÄ ‡∏´‡∏°‡∏∏‡∏ô‡∏†‡∏≤‡∏û‡∏ï‡∏≤‡∏°‡∏≠‡∏á‡∏®‡∏≤ */
async function rotateImage(img, degrees) {
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  const radians = (degrees * Math.PI) / 180;

  if (degrees % 180 === 0) {
    canvas.width = img.width;
    canvas.height = img.height;
  } else {
    canvas.width = img.height;
    canvas.height = img.width;
  }

  ctx.translate(canvas.width / 2, canvas.height / 2);
  ctx.rotate(radians);
  ctx.drawImage(img, -img.width / 2, -img.height / 2);
  return await faceapi.bufferToImage(canvas.toDataURL("image/jpeg"));
}

/* ‚úÇÔ∏è crop ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏™‡πà‡∏ß‡∏ô‡∏Ç‡∏≠‡∏á‡∏†‡∏≤‡∏û */
async function cropImage(img, x, y, w, h) {
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  canvas.width = w;
  canvas.height = h;
  ctx.drawImage(img, x, y, w, h, 0, 0, w, h);
  return await faceapi.bufferToImage(canvas.toDataURL("image/jpeg"));
}

    

    function addFailedPreview(path, imgUrl, reason) {
      if (failedImages.has(path)) return;
      failedImages.set(path, true);
      const div = document.createElement("div");
      div.className = "bg-slate-700 p-2 rounded relative";
      div.innerHTML = `
        <img src="${imgUrl}" alt="${path}" class="rounded w-full object-cover h-40"/>
        <p class="text-xs text-center mt-1 text-red-300">${reason}</p>
        <button class="absolute bottom-2 right-2 bg-blue-600 hover:bg-blue-700 text-xs px-2 py-1 rounded retry-btn">Retry</button>
      `;
      $("failedGrid").appendChild(div);
      div.querySelector(".retry-btn").onclick = async () => {
        div.style.opacity = "0.5";
        await handleSync(path, { [path]: { updated_at: new Date().toISOString() } }, loadCache(), 0, true);
        div.remove();
        failedImages.delete(path);
      };
    }

    async function handleSync(path, map, cache, attempt = 0, singleRetry = false) {
      const cacheT = cache[path], updated = map[path].updated_at;
      if (!singleRetry && cacheT && updated <= cacheT) { stats.skipped++; if(!processedSet.has(path)){processedSet.add(path);stats.processed++;} updateStats(); return; }
      try {
        const { data: exists } = await supabase.from("faces").select("id").eq("image_url", path).maybeSingle();
        if (exists) { stats.skipped++; if(!processedSet.has(path)){processedSet.add(path);stats.processed++;} cache[path] = updated; saveCache(cache); updateStats(); return; }

        const imgUrl = `${SUPABASE_URL}/storage/v1/object/public/${BUCKET}/${encodeURIComponent(path)}`;
        const img = await faceapi.fetchImage(imgUrl);
        const det = await detectFaceSmart(img);
        if (!det) throw new Error("‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤");
        const minFace = Number($("minFaceSize").value) || 50;
        if (det.detection.box.width < minFace || det.detection.box.height < minFace) throw new Error("‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏•‡πá‡∏Å‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ");

        const emb = Array.from(det.descriptor);
        const name = path.split("/").pop().split(".").shift();
        const { error } = await supabase.rpc("insert_face_vector", { p_name: name, p_image_url: path, p_embedding: emb });
        if (error) throw new Error(error.message);

        stats.success++; cache[path] = updated; saveCache(cache); log("info", `‚úÖ ${path}`);
      } catch (err) {
        if (attempt < 2 && !singleRetry) { log("warn", `Retry ${attempt + 1}/3: ${path} (${err.message})`); await delay(500); return await handleSync(path, map, cache, attempt + 1); }
        else { log("error", `‚ùå ${path}: ${err.message}`); stats.failed++; const imgUrl = `${SUPABASE_URL}/storage/v1/object/public/${BUCKET}/${encodeURIComponent(path)}`; addFailedPreview(path, imgUrl, err.message); }
      } finally { if (!processedSet.has(path)) { processedSet.add(path); stats.processed++; updateStats(); } }
    }

    async function listRecursive(path = "", map = {}) {
      const limit = 1000; let offset = 0;
      while (true) {
        const { data, error } = await supabase.storage.from(BUCKET).list(path, { limit, offset });
        if (error) { log("error", `Storage list error: ${error.message}`); break; }
        if (!data || data.length === 0) break;
        for (const item of data) {
          if (!item.metadata) { if (item.name.startsWith(".")) continue; await listRecursive(path ? `${path}/${item.name}` : item.name, map); }
          else { const full = path ? `${path}/${item.name}` : item.name; map[full] = { updated_at: item.updated_at }; }
        }
        if (data.length < limit) break;
        offset += limit; await delay(100);
      } return map;
    }

    async function syncGallery() {
      if (isSyncing) return log("warn", "‚öôÔ∏è ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß");
      stopRequested = false; isSyncing = true;
      stats = { success: 0, skipped: 0, failed: 0, processed: 0, total: 0 };
      processedSet.clear(); updateStats(); startTime = Date.now();
      $("status").textContent = "üîÑ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ã‡∏¥‡∏á‡∏Ñ‡πå..."; $("failedGrid").innerHTML = "";
      try {
        await checkAPIKey();
        const map = await listRecursive("");
        const files = Object.keys(map).filter(p => p.match(/\.(jpg|jpeg|png|webp|gif)$/i));
        const cache = loadCache();
        stats.total = files.length; updateStats(); log("info", `‡∏û‡∏ö ${stats.total} ‡πÑ‡∏ü‡∏•‡πå`);
        const limit = Number($("rateLimit").value) || 5, delayMs = Number($("delayMs").value) || 200;
        await Promise.all(Array.from({ length: limit }, async (_, w) => {
          for (let i = w; i < files.length && !stopRequested; i += limit) {
            await handleSync(files[i], map, cache);
            if (delayMs) await delay(delayMs);
          }
        }));
        $("lastSync").textContent = "‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î: " + new Date().toLocaleString();
        $("status").textContent = `‚úÖ ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô (‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ${stats.success}, ‡∏Ç‡πâ‡∏≤‡∏° ${stats.skipped}, ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß ${stats.failed})`;
      } catch (e) {
        log("error", "Critical: " + e.message);
        $("status").textContent = "‚ùå Error";
      } finally {
        isSyncing = false;
      }
    }

    $("syncNow").onclick = syncGallery;
    $("stopAuto").onclick = () => { stopRequested = true; log("warn", "‚è∏Ô∏è ‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡πÅ‡∏•‡πâ‡∏ß"); };
    $("clearLog").onclick = () => { $("log").innerHTML = ""; stats = { success: 0, skipped: 0, failed: 0, processed: 0, total: 0 }; updateStats(); };
    $("clearCache").onclick = () => { localStorage.removeItem("gallery-cache"); log("info", "üßπ ‡∏•‡πâ‡∏≤‡∏á cache ‡πÅ‡∏•‡πâ‡∏ß"); };
    $("autoSyncToggle").onchange = e => e.target.checked ? autoSyncId = setInterval(syncGallery, Number($("autoInterval").value)*1000) : clearInterval(autoSyncId);

    window.addEventListener("DOMContentLoaded", async () => {
      await loadModels();
      setInterval(() => $("elapsed").textContent = Math.floor((Date.now() - startTime) / 1000) + "s", 1000);
    });
  </script>
</body>
</html>
