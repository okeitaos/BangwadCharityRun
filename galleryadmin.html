<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Admin v2.6 | Face Sync (Smart Dual-Detector + Auto-Retry)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://cdn.jsdelivr.net/npm/@vladmandic/face-api@1.7.4/dist/face-api.min.js"></script>
</head>
<body class="bg-slate-900 text-white min-h-screen p-6">
  <div class="max-w-5xl mx-auto">
    <h1 class="text-3xl font-bold mb-4 text-center">üß† Admin v2.6 ‚Äî Dual-Detector + Auto-Retry (Smart & Safe)</h1>

    <!-- Control panel -->
    <div class="bg-slate-800 rounded-xl p-5 mb-4 shadow">
      <div class="flex flex-wrap gap-3 items-center justify-between">
        <div>
          <p id="status" class="text-gray-300">‚è≥ Loading models...</p>
          <p id="lastSync" class="text-gray-400 text-sm mt-1">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏ã‡∏¥‡∏á‡∏Ñ‡πå</p>
        </div>
        <div class="flex flex-wrap gap-3 items-center">
          <label class="text-sm text-gray-300">MIN FACE</label>
          <input id="minFaceSize" type="number" value="50" class="w-20 px-2 py-1 rounded bg-slate-700 text-white"/>
          <label class="text-sm text-gray-300">Rate Limit</label>
          <input id="rateLimit" type="number" value="5" class="w-20 px-2 py-1 rounded bg-slate-700 text-white"/>
          <label class="text-sm text-gray-300">Delay (ms)</label>
          <input id="delayMs" type="number" value="200" class="w-24 px-2 py-1 rounded bg-slate-700 text-white"/>
          <label class="text-sm text-gray-300">Auto Sync</label>
          <input id="autoSyncToggle" type="checkbox" class="h-5 w-5"/>
          <label class="text-sm text-gray-300">Interval (s)</label>
          <input id="autoInterval" type="number" value="60" class="w-20 px-2 py-1 rounded bg-slate-700 text-white"/>
        </div>
      </div>

      <div class="mt-4 flex flex-wrap gap-2">
        <button id="syncNow" class="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded">üîÅ Sync Now</button>
        <button id="stopAuto" class="bg-yellow-600 hover:bg-yellow-700 px-4 py-2 rounded">‚è∏Ô∏è Stop Auto</button>
        <button id="clearLog" class="bg-red-600 hover:bg-red-700 px-4 py-2 rounded">üßπ Clear Log</button>
        <button id="clearCache" class="bg-gray-600 hover:bg-gray-700 px-4 py-2 rounded">üóëÔ∏è Clear Cache</button>
      </div>
    </div>

    <!-- Progress -->
    <div class="bg-slate-800 rounded-xl p-5 mb-4 shadow">
      <div class="flex justify-between text-sm text-gray-300 mb-2">
        <div>Processed: <span id="processed">0</span>/<span id="total">0</span></div>
        <div>Elapsed: <span id="elapsed">0s</span></div>
      </div>
      <div class="w-full bg-slate-700 rounded h-4 mb-3 overflow-hidden">
        <div id="progressBar" class="h-4 bg-green-500 w-0 transition-all"></div>
      </div>
      <div class="grid grid-cols-3 gap-3 text-center">
        <div class="bg-slate-700 p-3 rounded"><div>‚úÖ Success</div><div id="countSuccess" class="text-2xl font-bold text-green-400">0</div></div>
        <div class="bg-slate-700 p-3 rounded"><div>‚öôÔ∏è Skipped</div><div id="countSkipped" class="text-2xl font-bold text-blue-300">0</div></div>
        <div class="bg-slate-700 p-3 rounded"><div>‚ùå Failed</div><div id="countFailed" class="text-2xl font-bold text-red-400">0</div></div>
      </div>
    </div>

    <!-- Log -->
    <div class="bg-slate-800 rounded-xl p-4 shadow mb-6">
      <h2 class="text-lg font-semibold mb-2">üìú Log</h2>
      <div id="log" class="h-72 overflow-y-auto bg-slate-900/30 p-3 rounded text-xs font-mono"></div>
    </div>
  </div>

  <script type="module">
    import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm'

    const SUPABASE_URL = "https://xjdjurdflowiwdxgkvfr.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InhqZGp1cmRmbG93aXdkeGdrdmZyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQzMDk5OTEsImV4cCI6MjA2OTg4NTk5MX0.QtWt1IrY1UYKmj0spL3T8CkaQh9wq2P-_4b6eWB3ics";
    const BUCKET = "gallery";
    const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    const $ = id => document.getElementById(id);
    const log = (type, text) => {
      const time = new Date().toLocaleTimeString();
      const color = type === 'error' ? 'text-red-300' : type === 'warn' ? 'text-yellow-300' : 'text-green-300';
      const div = document.createElement('div');
      div.className = `${color} mb-1`;
      div.innerHTML = `<span class="text-gray-400">[${time}]</span> ${text}`;
      $("log").prepend(div);
    };

    let isSyncing = false, stopRequested = false, autoSyncId = null, startTime = null;
    let stats = { success: 0, skipped: 0, failed: 0, processed: 0, total: 0 };

    const delay = ms => new Promise(r => setTimeout(r, ms));
    const updateStats = () => {
      $("countSuccess").textContent = stats.success;
      $("countSkipped").textContent = stats.skipped;
      $("countFailed").textContent = stats.failed;
      $("processed").textContent = stats.processed;
      $("total").textContent = stats.total;
      $("progressBar").style.width = (stats.total ? Math.round((stats.processed / stats.total) * 100) : 0) + "%";
    };
    const loadCache = () => JSON.parse(localStorage.getItem("gallery-cache") || "{}");
    const saveCache = c => localStorage.setItem("gallery-cache", JSON.stringify(c));
    const clearCache = () => { localStorage.removeItem("gallery-cache"); log("info", "üßπ ‡∏•‡πâ‡∏≤‡∏á cache ‡πÅ‡∏•‡πâ‡∏ß"); };

    async function loadModels() {
      $("status").textContent = "‚è≥ ‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏•...";
      const modelURL = "https://cdn.jsdelivr.net/npm/@vladmandic/face-api@1.7.4/model/";
      await Promise.all([
        faceapi.nets.ssdMobilenetv1.loadFromUri(modelURL),
        faceapi.nets.tinyFaceDetector.loadFromUri(modelURL),
        faceapi.nets.faceLandmark68Net.loadFromUri(modelURL),
        faceapi.nets.faceRecognitionNet.loadFromUri(modelURL)
      ]);
      $("status").textContent = "‚úÖ ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏ã‡∏¥‡∏á‡∏Ñ‡πå";
      log("info", "‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏Ñ‡∏£‡∏ö‡πÅ‡∏•‡πâ‡∏ß");
    }

    async function detectFaceSmart(img, retry = 0) {
      try {
        let det = await faceapi.detectSingleFace(img).withFaceLandmarks().withFaceDescriptor();
        if (!det) {
          det = await faceapi.detectSingleFace(img, new faceapi.TinyFaceDetectorOptions({ inputSize: 416, scoreThreshold: 0.4 })).withFaceLandmarks().withFaceDescriptor();
        }
        return det;
      } catch (e) {
        if (retry < 2) {
          log("warn", `üîÑ Retry detect (${retry + 1})`);
          await delay(300);
          return await detectFaceSmart(img, retry + 1);
        } else {
          throw e;
        }
      }
    }

    async function handleSync(path, map, cache, attempt = 0) {
      const cacheT = cache[path], updated = map[path].updated_at;
      if (cacheT && updated <= cacheT) {
        stats.skipped++; stats.processed++; updateStats(); return;
      }
      try {
        const { data: exists } = await supabase.from("faces").select("id").eq("image_url", path).maybeSingle();
        if (exists) {
          stats.skipped++; stats.processed++; cache[path] = updated; saveCache(cache); updateStats(); return;
        }

        const imgUrl = `${SUPABASE_URL}/storage/v1/object/public/${BUCKET}/${encodeURIComponent(path)}`;
        const img = await faceapi.fetchImage(imgUrl);
        const det = await detectFaceSmart(img);
        if (!det) throw new Error("‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤");
        const minFace = Number($("minFaceSize").value) || 50;
        if (det.detection.box.width < minFace || det.detection.box.height < minFace) throw new Error("‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏•‡πá‡∏Å‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ");

        const emb = Array.from(det.descriptor);
        const name = path.split("/").pop().split(".").shift();
        const { error } = await supabase.rpc("insert_face_vector", { p_name: name, p_image_url: path, p_embedding: emb });
        if (error) throw new Error(error.message);

        stats.success++; cache[path] = updated; saveCache(cache); log("info", `‚úÖ ${path}`);
      } catch (err) {
        if (attempt < 2) {
          log("warn", `Retry ${attempt + 1}/3: ${path} (${err.message})`);
          await delay(500);
          return await handleSync(path, map, cache, attempt + 1);
        } else {
          log("error", `‚ùå ${path}: ${err.message}`);
          stats.failed++;
        }
      } finally {
        stats.processed++; updateStats();
      }
    }

    async function listRecursive(path = "", map = {}) {
      const { data, error } = await supabase.storage.from(BUCKET).list(path, { limit: 1000 });
      if (error) return map;
      for (const item of data) {
        if (!item.metadata) {
          if (item.name.startsWith(".")) continue;
          await listRecursive(path ? `${path}/${item.name}` : item.name, map);
        } else {
          map[path ? `${path}/${item.name}` : item.name] = { updated_at: item.updated_at };
        }
      }
      return map;
    }

    async function processWithRateLimit(items, limit, fn, delayMs) {
      let idx = 0;
      async function worker() {
        while (idx < items.length && !stopRequested) {
          const i = idx++;
          await fn(items[i]);
          if (delayMs) await delay(delayMs);
        }
      }
      await Promise.all(Array.from({ length: limit }, worker));
    }

    async function syncGallery() {
      if (isSyncing) return log("warn", "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß");
      stopRequested = false; isSyncing = true;
      stats = { success: 0, skipped: 0, failed: 0, processed: 0, total: 0 };
      updateStats(); startTime = Date.now(); $("status").textContent = "üîÑ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ã‡∏¥‡∏á‡∏Ñ‡πå...";
      try {
        const map = await listRecursive("");
        const files = Object.keys(map).filter(p => p.match(/\.(jpg|jpeg|png|webp|gif)$/i));
        const cache = loadCache();
        stats.total = files.length; updateStats(); log("info", `‡∏û‡∏ö ${stats.total} ‡πÑ‡∏ü‡∏•‡πå`);
        const limit = Number($("rateLimit").value) || 5, delayMs = Number($("delayMs").value) || 200;
        await processWithRateLimit(files, limit, async p => await handleSync(p, map, cache), delayMs);
        $("lastSync").textContent = "‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î: " + new Date().toLocaleString();
        $("status").textContent = `‚úÖ ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô (‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ${stats.success}, ‡∏Ç‡πâ‡∏≤‡∏° ${stats.skipped}, ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß ${stats.failed})`;
      } catch (e) {
        log("error", "Critical: " + e.message);
        $("status").textContent = "‚ùå Error";
      } finally {
        isSyncing = false;
      }
    }

    const stopAuto = () => { if (autoSyncId) clearInterval(autoSyncId); autoSyncId = null; $("autoSyncToggle").checked = false; log("info", "Auto Sync ‡∏´‡∏¢‡∏∏‡∏î‡πÅ‡∏•‡πâ‡∏ß"); };
    const startAutoSync = () => { stopAuto(); const s = Math.max(10, Number($("autoInterval").value) || 60); autoSyncId = setInterval(() => { if (!isSyncing) syncGallery(); }, s * 1000); $("autoSyncToggle").checked = true; log("info", `Auto Sync ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ó‡∏∏‡∏Å ${s}s`); };

    $("syncNow").onclick = syncGallery;
    $("stopAuto").onclick = () => { stopRequested = true; stopAuto(); };
    $("clearLog").onclick = () => { $("log").innerHTML = ""; stats = { success: 0, skipped: 0, failed: 0, processed: 0, total: 0 }; updateStats(); };
    $("clearCache").onclick = clearCache;
    $("autoSyncToggle").onchange = e => e.target.checked ? startAutoSync() : stopAuto();

    window.addEventListener("DOMContentLoaded", async () => { await loadModels(); setInterval(() => $("elapsed").textContent = Math.floor((Date.now() - startTime) / 1000) + "s", 1000); });
  </script>
</body>
</html>
