<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Admin v2.7.3 | Face Sync (Smart Detect+)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://cdn.jsdelivr.net/npm/@vladmandic/face-api@1.7.4/dist/face-api.min.js"></script>
</head>
<body class="bg-slate-900 text-white min-h-screen p-6">
  <div class="max-w-6xl mx-auto">
    <h1 class="text-3xl font-bold mb-4 text-center">üß† Admin v2.7.3 ‚Äî Smart Face Sync Dashboard</h1>

    <!-- Control Panel -->
    <div class="bg-slate-800 rounded-xl p-5 mb-4 shadow">
      <div class="flex flex-wrap gap-3 items-center justify-between">
        <div>
          <p id="status" class="text-gray-300">‚è≥ Loading models...</p>
          <p id="lastSync" class="text-gray-400 text-sm mt-1">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏ã‡∏¥‡∏á‡∏Ñ‡πå</p>
        </div>
        <div class="flex flex-wrap gap-3 items-center">
          <label class="text-sm text-gray-300">MIN FACE</label>
          <input id="minFaceSize" type="number" value="50" class="w-20 px-2 py-1 rounded bg-slate-700 text-white"/>
          <label class="text-sm text-gray-300">Rate Limit</label>
          <input id="rateLimit" type="number" value="5" class="w-20 px-2 py-1 rounded bg-slate-700 text-white"/>
          <label class="text-sm text-gray-300">Delay (ms)</label>
          <input id="delayMs" type="number" value="200" class="w-24 px-2 py-1 rounded bg-slate-700 text-white"/>
          <label class="text-sm text-gray-300">Auto Sync</label>
          <input id="autoSyncToggle" type="checkbox" class="h-5 w-5"/>
          <label class="text-sm text-gray-300">Interval (s)</label>
          <input id="autoInterval" type="number" value="60" class="w-20 px-2 py-1 rounded bg-slate-700 text-white"/>
        </div>
      </div>

      <div class="mt-4 flex flex-wrap gap-2">
        <button id="syncNow" class="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded">üîÅ Sync Now</button>
        <button id="stopAuto" class="bg-yellow-600 hover:bg-yellow-700 px-4 py-2 rounded">‚è∏Ô∏è Stop Auto</button>
        <button id="clearLog" class="bg-red-600 hover:bg-red-700 px-4 py-2 rounded">üßπ Clear Log</button>
        <button id="clearCache" class="bg-gray-600 hover:bg-gray-700 px-4 py-2 rounded">üóëÔ∏è Clear Cache</button>
      </div>
    </div>

    <!-- Progress -->
    <div class="bg-slate-800 rounded-xl p-5 mb-4 shadow">
      <div class="flex justify-between text-sm text-gray-300 mb-2">
        <div>Processed: <span id="processed">0</span>/<span id="total">0</span></div>
        <div>Elapsed: <span id="elapsed">0s</span></div>
      </div>
      <div class="w-full bg-slate-700 rounded h-4 mb-3 overflow-hidden">
        <div id="progressBar" class="h-4 bg-green-500 w-0 transition-all"></div>
      </div>
      <div class="grid grid-cols-3 gap-3 text-center">
        <div class="bg-slate-700 p-3 rounded"><div>‚úÖ Success</div><div id="countSuccess" class="text-2xl font-bold text-green-400">0</div></div>
        <div class="bg-slate-700 p-3 rounded"><div>‚öôÔ∏è Skipped</div><div id="countSkipped" class="text-2xl font-bold text-blue-300">0</div></div>
        <div class="bg-slate-700 p-3 rounded"><div>‚ùå Failed</div><div id="countFailed" class="text-2xl font-bold text-red-400">0</div></div>
      </div>
    </div>

    <!-- Log -->
    <div class="bg-slate-800 rounded-xl p-4 shadow mb-6">
      <h2 class="text-lg font-semibold mb-2">üìú Log</h2>
      <div id="log" class="h-72 overflow-y-auto bg-slate-900/30 p-3 rounded text-xs font-mono"></div>
    </div>

    <!-- Failed Preview -->
    <div class="bg-slate-800 rounded-xl p-4 shadow">
      <h2 class="text-lg font-semibold mb-3">‚ùå ‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏ß‡∏à‡πÑ‡∏°‡πà‡∏ú‡πà‡∏≤‡∏ô</h2>
      <div id="failedGrid" class="grid grid-cols-2 md:grid-cols-4 gap-3"></div>
    </div>
  </div>

  <script type="module">
    import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm";
    const SUPABASE_URL = "https://xjdjurdflowiwdxgkvfr.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InhqZGp1cmRmbG93aXdkeGdrdmZyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQzMDk5OTEsImV4cCI6MjA2OTg4NTk5MX0.QtWt1IrY1UYKmj0spL3T8CkaQh9wq2P-_4b6eWB3ics";
    const BUCKET = "gallery";
    const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    const $ = id => document.getElementById(id);
    const delay = ms => new Promise(r => setTimeout(r, ms));

    const log = (type, text) => {
      const time = new Date().toLocaleTimeString();
      const color = type === "error" ? "text-red-300" : type === "warn" ? "text-yellow-300" : "text-green-300";
      const div = document.createElement("div");
      div.className = `${color} mb-1`;
      div.innerHTML = `<span class="text-gray-400">[${time}]</span> ${text}`;
      $("log").prepend(div);
    };

    let isSyncing = false, stopRequested = false, autoSyncId = null, startTime = null;
    let stats = { success: 0, skipped: 0, failed: 0, processed: 0, total: 0 };
    const processedSet = new Set();
    const failedImages = new Map();

    /* üìä ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡πÅ‡∏•‡∏∞ Progress Bar */
    function updateStats() {
      $("countSuccess").textContent = stats.success;
      $("countSkipped").textContent = stats.skipped;
      $("countFailed").textContent = stats.failed;
      $("processed").textContent = stats.processed;
      $("total").textContent = stats.total;
      const percent = stats.total ? Math.round((stats.processed / stats.total) * 100) : 0;
      $("progressBar").style.width = percent + "%";
    }

    const loadCache = () => JSON.parse(localStorage.getItem("gallery-cache") || "{}");
    const saveCache = c => localStorage.setItem("gallery-cache", JSON.stringify(c));

    async function checkAPIKey() {
      try {
        const { error } = await supabase.from("faces").select("id").limit(1);
        if (error) throw error;
        log("info", "‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏µ‡∏¢‡πå Supabase ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô");
      } catch (e) {
        log("error", "‚ùå Invalid API key: " + e.message);
        $("status").textContent = "‚ùå Invalid API key";
        throw e;
      }
    }

    async function loadModels() {
      $("status").textContent = "‚è≥ ‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏•...";
      const modelURL = "https://cdn.jsdelivr.net/npm/@vladmandic/face-api@1.7.4/model/";
      await Promise.all([
        faceapi.nets.ssdMobilenetv1.loadFromUri(modelURL),
        faceapi.nets.tinyFaceDetector.loadFromUri(modelURL),
        faceapi.nets.faceLandmark68Net.loadFromUri(modelURL),
        faceapi.nets.faceRecognitionNet.loadFromUri(modelURL)
      ]);
      $("status").textContent = "‚úÖ ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏ã‡∏¥‡∏á‡∏Ñ‡πå";
      log("info", "üì¶ ‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏Ñ‡∏£‡∏ö‡πÅ‡∏•‡πâ‡∏ß");
    }

    async function detectFaceSmart(img, retry = 0) {
      try {
        let det = await faceapi.detectSingleFace(img).withFaceLandmarks().withFaceDescriptor();
        if (!det)
          det = await faceapi.detectSingleFace(img, new faceapi.TinyFaceDetectorOptions({ inputSize: 416, scoreThreshold: 0.4 }))
            .withFaceLandmarks().withFaceDescriptor();
        return det;
      } catch (e) {
        if (retry < 2) {
          await delay(300);
          return await detectFaceSmart(img, retry + 1);
        } else throw e;
      }
    }

    function addFailedPreview(path, imgUrl, reason) {
      if (failedImages.has(path)) return;
      failedImages.set(path, true);
      const div = document.createElement("div");
      div.className = "bg-slate-700 p-2 rounded relative";
      div.innerHTML = `
        <img src="${imgUrl}" alt="${path}" class="rounded w-full object-cover h-40"/>
        <p class="text-xs text-center mt-1 text-red-300">${reason}</p>
        <button class="absolute bottom-2 right-2 bg-blue-600 hover:bg-blue-700 text-xs px-2 py-1 rounded retry-btn">Retry</button>
      `;
      $("failedGrid").appendChild(div);
      div.querySelector(".retry-btn").onclick = async () => {
        div.style.opacity = "0.5";
        await handleSync(path, { [path]: { updated_at: new Date().toISOString() } }, loadCache(), 0, true);
        div.remove();
        failedImages.delete(path);
      };
    }

    async function handleSync(path, map, cache, attempt = 0, singleRetry = false) {
      const cacheT = cache[path], updated = map[path].updated_at;
      if (!singleRetry && cacheT && updated <= cacheT) { stats.skipped++; if(!processedSet.has(path)){processedSet.add(path);stats.processed++;} updateStats(); return; }
      try {
        const { data: exists } = await supabase.from("faces").select("id").eq("image_url", path).maybeSingle();
        if (exists) { stats.skipped++; if(!processedSet.has(path)){processedSet.add(path);stats.processed++;} cache[path] = updated; saveCache(cache); updateStats(); return; }

        const imgUrl = `${SUPABASE_URL}/storage/v1/object/public/${BUCKET}/${encodeURIComponent(path)}`;
        const img = await faceapi.fetchImage(imgUrl);
        const det = await detectFaceSmart(img);
        if (!det) throw new Error("‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤");
        const minFace = Number($("minFaceSize").value) || 50;
        if (det.detection.box.width < minFace || det.detection.box.height < minFace) throw new Error("‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏•‡πá‡∏Å‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ");

        const emb = Array.from(det.descriptor);
        const name = path.split("/").pop().split(".").shift();
        const { error } = await supabase.rpc("insert_face_vector", { p_name: name, p_image_url: path, p_embedding: emb });
        if (error) throw new Error(error.message);

        stats.success++; cache[path] = updated; saveCache(cache); log("info", `‚úÖ ${path}`);
      } catch (err) {
        if (attempt < 2 && !singleRetry) { log("warn", `Retry ${attempt + 1}/3: ${path} (${err.message})`); await delay(500); return await handleSync(path, map, cache, attempt + 1); }
        else { log("error", `‚ùå ${path}: ${err.message}`); stats.failed++; const imgUrl = `${SUPABASE_URL}/storage/v1/object/public/${BUCKET}/${encodeURIComponent(path)}`; addFailedPreview(path, imgUrl, err.message); }
      } finally { if (!processedSet.has(path)) { processedSet.add(path); stats.processed++; updateStats(); } }
    }

    async function listRecursive(path = "", map = {}) {
      const limit = 1000; let offset = 0;
      while (true) {
        const { data, error } = await supabase.storage.from(BUCKET).list(path, { limit, offset });
        if (error) { log("error", `Storage list error: ${error.message}`); break; }
        if (!data || data.length === 0) break;
        for (const item of data) {
          if (!item.metadata) { if (item.name.startsWith(".")) continue; await listRecursive(path ? `${path}/${item.name}` : item.name, map); }
          else { const full = path ? `${path}/${item.name}` : item.name; map[full] = { updated_at: item.updated_at }; }
        }
        if (data.length < limit) break;
        offset += limit; await delay(100);
      } return map;
    }

    async function syncGallery() {
      if (isSyncing) return log("warn", "‚öôÔ∏è ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß");
      stopRequested = false; isSyncing = true;
      stats = { success: 0, skipped: 0, failed: 0, processed: 0, total: 0 };
      processedSet.clear(); updateStats(); startTime = Date.now();
      $("status").textContent = "üîÑ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ã‡∏¥‡∏á‡∏Ñ‡πå..."; $("failedGrid").innerHTML = "";
      try {
        await checkAPIKey();
        const map = await listRecursive("");
        const files = Object.keys(map).filter(p => p.match(/\.(jpg|jpeg|png|webp|gif)$/i));
        const cache = loadCache();
        stats.total = files.length; updateStats(); log("info", `‡∏û‡∏ö ${stats.total} ‡πÑ‡∏ü‡∏•‡πå`);
        const limit = Number($("rateLimit").value) || 5, delayMs = Number($("delayMs").value) || 200;
        await Promise.all(Array.from({ length: limit }, async (_, w) => {
          for (let i = w; i < files.length && !stopRequested; i += limit) {
            await handleSync(files[i], map, cache);
            if (delayMs) await delay(delayMs);
          }
        }));
        $("lastSync").textContent = "‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î: " + new Date().toLocaleString();
        $("status").textContent = `‚úÖ ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô (‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ${stats.success}, ‡∏Ç‡πâ‡∏≤‡∏° ${stats.skipped}, ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß ${stats.failed})`;
      } catch (e) {
        log("error", "Critical: " + e.message);
        $("status").textContent = "‚ùå Error";
      } finally {
        isSyncing = false;
      }
    }

    $("syncNow").onclick = syncGallery;
    $("stopAuto").onclick = () => { stopRequested = true; log("warn", "‚è∏Ô∏è ‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡πÅ‡∏•‡πâ‡∏ß"); };
    $("clearLog").onclick = () => { $("log").innerHTML = ""; stats = { success: 0, skipped: 0, failed: 0, processed: 0, total: 0 }; updateStats(); };
    $("clearCache").onclick = () => { localStorage.removeItem("gallery-cache"); log("info", "üßπ ‡∏•‡πâ‡∏≤‡∏á cache ‡πÅ‡∏•‡πâ‡∏ß"); };
    $("autoSyncToggle").onchange = e => e.target.checked ? autoSyncId = setInterval(syncGallery, Number($("autoInterval").value)*1000) : clearInterval(autoSyncId);

    window.addEventListener("DOMContentLoaded", async () => {
      await loadModels();
      setInterval(() => $("elapsed").textContent = Math.floor((Date.now() - startTime) / 1000) + "s", 1000);
    });
  </script>
</body>
</html>
