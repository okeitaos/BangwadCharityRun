<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Admin v3.0 UltraStable | Smart Face Sync Dashboard</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://cdn.jsdelivr.net/npm/@vladmandic/face-api@1.7.4/dist/face-api.min.js"></script>
</head>

<body class="bg-slate-900 text-white min-h-screen p-6">
  <div class="max-w-6xl mx-auto">
    <h1 class="text-3xl font-bold mb-4 text-center">
      üß† Admin v3.0 ‚Äî Smart Face Sync Dashboard (UltraStable)
    </h1>

    <!-- üß© Control Panel -->
    <div class="bg-slate-800 rounded-xl p-5 mb-4 shadow">
      <div class="flex flex-wrap gap-3 items-center justify-between">
        <div>
          <p id="status" class="text-gray-300">‚è≥ Loading models...</p>
          <p id="lastSync" class="text-gray-400 text-sm mt-1">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏ã‡∏¥‡∏á‡∏Ñ‡πå</p>
        </div>
        <div class="flex flex-wrap gap-3 items-center">
          <label class="text-sm text-gray-300">MIN FACE</label>
          <input id="minFaceSize" type="number" value="50" class="w-20 px-2 py-1 rounded bg-slate-700 text-white"/>
          <label class="text-sm text-gray-300">Rate Limit</label>
          <input id="rateLimit" type="number" value="5" class="w-20 px-2 py-1 rounded bg-slate-700 text-white"/>
          <label class="text-sm text-gray-300">Delay (ms)</label>
          <input id="delayMs" type="number" value="200" class="w-24 px-2 py-1 rounded bg-slate-700 text-white"/>
          <label class="text-sm text-gray-300">Auto Sync</label>
          <input id="autoSyncToggle" type="checkbox" class="h-5 w-5"/>
          <label class="text-sm text-gray-300">Interval (s)</label>
          <input id="autoInterval" type="number" value="60" class="w-20 px-2 py-1 rounded bg-slate-700 text-white"/>
        </div>
      </div>

      <div class="mt-4 flex flex-wrap gap-2">
        <button id="syncNow" class="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded">üîÅ Sync Now</button>
        <button id="stopAuto" class="bg-yellow-600 hover:bg-yellow-700 px-4 py-2 rounded">‚è∏Ô∏è Stop Auto</button>
        <button id="clearLog" class="bg-red-600 hover:bg-red-700 px-4 py-2 rounded">üßπ Clear Log</button>
        <button id="clearCache" class="bg-gray-600 hover:bg-gray-700 px-4 py-2 rounded">üóëÔ∏è Clear Cache</button>
      </div>
    </div>

    <!-- Progress -->
    <div class="bg-slate-800 rounded-xl p-5 mb-4 shadow">
      <div class="flex justify-between text-sm text-gray-300 mb-2">
        <div>Processed: <span id="processed">0</span>/<span id="total">0</span></div>
        <div>Elapsed: <span id="elapsed">0s</span></div>
      </div>
      <div class="w-full bg-slate-700 rounded h-4 mb-3 overflow-hidden">
        <div id="progressBar" class="h-4 bg-green-500 w-0 transition-all"></div>
      </div>
      <div class="grid grid-cols-3 gap-3 text-center">
        <div class="bg-slate-700 p-3 rounded"><div>‚úÖ Success</div><div id="countSuccess" class="text-2xl font-bold text-green-400">0</div></div>
        <div class="bg-slate-700 p-3 rounded"><div>‚öôÔ∏è Skipped</div><div id="countSkipped" class="text-2xl font-bold text-blue-300">0</div></div>
        <div class="bg-slate-700 p-3 rounded"><div>‚ùå Failed</div><div id="countFailed" class="text-2xl font-bold text-red-400">0</div></div>
      </div>
    </div>

    <!-- Log -->
    <div class="bg-slate-800 rounded-xl p-4 shadow mb-6">
      <h2 class="text-lg font-semibold mb-2">üìú Log</h2>
      <div id="log" class="h-72 overflow-y-auto bg-slate-900/30 p-3 rounded text-xs font-mono"></div>
    </div>

    <!-- Failed Preview -->
    <div class="bg-slate-800 rounded-xl p-4 shadow">
      <h2 class="text-lg font-semibold mb-3">‚ùå ‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏ß‡∏à‡πÑ‡∏°‡πà‡∏ú‡πà‡∏≤‡∏ô</h2>
      <div id="failedGrid" class="grid grid-cols-2 md:grid-cols-4 gap-3"></div>
    </div>
  </div>

<script type="module">
import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm";
const SUPABASE_URL = "https://xjdjurdflowiwdxgkvfr.supabase.co";
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...";
const BUCKET = "gallery";
const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

const $ = id => document.getElementById(id);
const delay = ms => new Promise(r => setTimeout(r, ms));
const log = (type, text) => {
  const time = new Date().toLocaleTimeString();
  const color = type === "error" ? "text-red-300" : type === "warn" ? "text-yellow-300" : "text-green-300";
  const div = document.createElement("div");
  div.className = `${color} mb-1`;
  div.innerHTML = `<span class="text-gray-400">[${time}]</span> ${text}`;
  $("log").prepend(div);
};

let isSyncing = false, stopRequested = false, startTime = null;
let stats = { success: 0, skipped: 0, failed: 0, processed: 0, total: 0 };
const processedSet = new Set();
const failedImages = new Map();

/* ‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏• */
async function loadModels() {
  $("status").textContent = "‚è≥ ‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏•...";
  const modelURL = "https://cdn.jsdelivr.net/npm/@vladmandic/face-api@1.7.4/model/";
  await Promise.all([
    faceapi.nets.ssdMobilenetv1.loadFromUri(modelURL),
    faceapi.nets.tinyFaceDetector.loadFromUri(modelURL),
    faceapi.nets.faceLandmark68Net.loadFromUri(modelURL),
    faceapi.nets.faceRecognitionNet.loadFromUri(modelURL)
  ]);
  $("status").textContent = "‚úÖ ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏ã‡∏¥‡∏á‡∏Ñ‡πå";
  log("info", "‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏Ñ‡∏£‡∏ö‡πÅ‡∏•‡πâ‡∏ß");
}

/* ‡πÇ‡∏´‡∏•‡∏î‡∏£‡∏π‡∏õ robust */
async function fetchImageRobust(url) {
  try {
    const resp = await fetch(url, { cache: "no-store" });
    const blob = await resp.blob();
    return await blobToImage(blob);
  } catch {
    return await faceapi.fetchImage(url);
  }
}

function blobToImage(blob) {
  return new Promise((res, rej) => {
    const url = URL.createObjectURL(blob);
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.onload = () => { URL.revokeObjectURL(url); res(img); };
    img.onerror = () => rej(new Error("load error"));
    img.src = url;
  });
}

/* ‡πÅ‡∏õ‡∏•‡∏á / ‡∏´‡∏°‡∏∏‡∏ô‡∏†‡∏≤‡∏û */
async function transformImage(img, { angle = 0, scale = 1 } = {}) {
  const rad = (angle * Math.PI) / 180;
  const w = img.width, h = img.height;
  const canvas = document.createElement("canvas");
  if (angle % 180 === 0) { canvas.width = w; canvas.height = h; }
  else { canvas.width = h; canvas.height = w; }
  const ctx = canvas.getContext("2d");
  ctx.translate(canvas.width / 2, canvas.height / 2);
  ctx.rotate(rad);
  ctx.scale(scale, scale);
  ctx.drawImage(img, -w / 2, -h / 2);
  const blob = await new Promise(r => canvas.toBlob(r, "image/jpeg", 0.95));
  return await blobToImage(blob);
}

/* ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏´‡∏°‡∏∏‡∏ô */
async function detectFaceWithRotationSupport(imgUrl, minFaceSize = 50) {
  const img = await fetchImageRobust(imgUrl);
  let det = await detectFaceMulti(img, { minFaceSize });
  if (det) return det;
  for (const angle of [90, 270]) {
    const rImg = await transformImage(img, { angle });
    det = await detectFaceMulti(rImg, { minFaceSize });
    if (det) return det;
  }
  return null;
}

/* ‡∏ï‡∏£‡∏ß‡∏à‡∏´‡∏•‡∏≤‡∏¢ scale */
async function detectFaceMulti(img, opts = {}) {
  const minFaceSize = opts.minFaceSize || 50;
  const dets = await faceapi.detectAllFaces(img, new faceapi.TinyFaceDetectorOptions({ inputSize: 640, scoreThreshold: 0.25 }))
    .withFaceLandmarks().withFaceDescriptors();
  if (!dets.length) return null;
  dets.sort((a,b)=>b.detection.box.width*b.detection.box.height - a.detection.box.width*a.detection.box.height);
  const best = dets[0];
  if (best.detection.box.width < minFaceSize || best.detection.box.height < minFaceSize) return null;
  return best;
}

/* ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥ */
function updateStats() {
  $("countSuccess").textContent = stats.success;
  $("countSkipped").textContent = stats.skipped;
  $("countFailed").textContent = stats.failed;
  $("processed").textContent = stats.processed;
  $("total").textContent = stats.total;
  $("progressBar").style.width = (stats.total ? Math.round((stats.processed / stats.total) * 100) : 0) + "%";
}

/* ‡πÅ‡∏Ñ‡∏ä */
const loadCache = () => JSON.parse(localStorage.getItem("gallery-cache") || "{}");
const saveCache = c => localStorage.setItem("gallery-cache", JSON.stringify(c));
const clearCache = () => { localStorage.removeItem("gallery-cache"); log("info", "üßπ ‡∏•‡πâ‡∏≤‡∏á cache ‡πÅ‡∏•‡πâ‡∏ß"); };

/* Preview fail */
function addFailedPreview(path, imgUrl, reason) {
  if (failedImages.has(path)) return;
  failedImages.set(path, true);
  const div = document.createElement("div");
  div.className = "bg-slate-700 p-2 rounded relative";
  div.innerHTML = `
    <img src="${imgUrl}" class="rounded w-full object-cover h-40"/>
    <p class="text-xs text-center mt-1 text-red-300">${reason}</p>
    <button class="absolute bottom-2 right-2 bg-blue-600 hover:bg-blue-700 text-xs px-2 py-1 rounded retry-btn">Retry</button>
  `;
  $("failedGrid").appendChild(div);
  div.querySelector(".retry-btn").onclick = async () => {
    div.style.opacity = "0.5";
    await handleSync(path, { [path]: { updated_at: new Date().toISOString() } }, loadCache(), 0, true);
    div.remove();
    failedImages.delete(path);
  };
}

/* handleSync (‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ï‡∏£‡∏ß‡∏à‡πÅ‡∏ö‡∏ö‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î) */
async function handleSync(path, map, cache, attempt = 0, singleRetry = false) {
  const cacheT = cache[path], updated = map[path].updated_at;
  if (!singleRetry && cacheT && updated <= cacheT) {
    stats.skipped++; if (!processedSet.has(path)) { processedSet.add(path); stats.processed++; } updateStats(); return;
  }
  try {
    const { data: exists } = await supabase.from("faces").select("id").eq("image_url", path).maybeSingle();
    if (exists) { stats.skipped++; if (!processedSet.has(path)) { processedSet.add(path); stats.processed++; } cache[path] = updated; saveCache(cache); updateStats(); return; }

    const imgUrl = `${SUPABASE_URL}/storage/v1/object/public/${BUCKET}/${encodeURIComponent(path)}`;
    const minFace = Number($("minFaceSize").value) || 50;
    const det = await detectFaceWithRotationSupport(imgUrl, minFace);
    if (!det) throw new Error("‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤");

    const emb = Array.from(det.descriptor);
    const name = path.split("/").pop().split(".").shift();
    const { error } = await supabase.rpc("insert_face_vector", { p_name: name, p_image_url: path, p_embedding: emb });
    if (error) throw new Error(error.message);

    stats.success++; cache[path] = updated; saveCache(cache); log("info", `‚úÖ ${path}`);
  } catch (err) {
    if (attempt < 2 && !singleRetry) { await delay(500); return await handleSync(path, map, cache, attempt + 1); }
    stats.failed++; log("error", `‚ùå ${path}: ${err.message}`);
    const imgUrl = `${SUPABASE_URL}/storage/v1/object/public/${BUCKET}/${encodeURIComponent(path)}`;
    addFailedPreview(path, imgUrl, err.message);
  } finally {
    if (!processedSet.has(path)) { processedSet.add(path); stats.processed++; updateStats(); }
  }
}

/* listRecursive */
async function listRecursive(path = "", map = {}) {
  const limit = 1000; let offset = 0;
  while (true) {
    const { data } = await supabase.storage.from(BUCKET).list(path, { limit, offset });
    if (!data || data.length === 0) break;
    for (const item of data) {
      if (!item.metadata) await listRecursive(path ? `${path}/${item.name}` : item.name, map);
      else map[path ? `${path}/${item.name}` : item.name] = { updated_at: item.updated_at };
    }
    if (data.length < limit) break;
    offset += limit; await delay(100);
  }
  return map;
}

/* syncGallery */
async function syncGallery() {
  if (isSyncing) return log("warn", "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß");
  stopRequested = false; isSyncing = true;
  stats = { success: 0, skipped: 0, failed: 0, processed: 0, total: 0 };
  processedSet.clear(); updateStats(); startTime = Date.now(); $("status").textContent = "üîÑ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ã‡∏¥‡∏á‡∏Ñ‡πå...";
  $("failedGrid").innerHTML = "";
  const map = await listRecursive("");
  const files = Object.keys(map).filter(p => p.match(/\.(jpg|jpeg|png|webp|gif)$/i));
  const cache = loadCache(); stats.total = files.length; updateStats();
  const limit = Number($("rateLimit").value) || 5, delayMs = Number($("delayMs").value) || 200;
  await Promise.all(Array.from({ length: limit }, async (_, w) => {
    for (let i = w; i < files.length && !stopRequested; i += limit) {
      await handleSync(files[i], map, cache);
      if (delayMs) await delay(delayMs);
    }
  }));
  $("status").textContent = `‚úÖ ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô (‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ${stats.success}, ‡∏Ç‡πâ‡∏≤‡∏° ${stats.skipped}, ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß ${stats.failed})`;
}

/* ‡∏õ‡∏∏‡πà‡∏° */
$("syncNow").onclick = syncGallery;
$("stopAuto").onclick = () => { stopRequested = true; log("warn", "‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡πÅ‡∏•‡πâ‡∏ß"); };
$("clearLog").onclick = () => { $("log").innerHTML = ""; stats = { success: 0, skipped: 0, failed: 0, processed: 0, total: 0 }; updateStats(); };
$("clearCache").onclick = clearCache;

let autoSyncId = null;
$("autoSyncToggle").onchange = e => {
  if (e.target.checked) autoSyncId = setInterval(syncGallery, Number($("autoInterval").value) * 1000);
  else clearInterval(autoSyncId);
};

setInterval(() => { if (startTime) $("elapsed").textContent = Math.floor((Date.now() - startTime) / 1000) + "s"; }, 1000);
window.addEventListener("DOMContentLoaded", loadModels);
</script>
</body>
</html>
