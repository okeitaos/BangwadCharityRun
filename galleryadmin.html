<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Admin v2.1 | Face Sync (Smart + Fast)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://cdn.jsdelivr.net/npm/@vladmandic/face-api@1.7.4/dist/face-api.min.js"></script>
</head>
<body class="bg-slate-900 text-white min-h-screen p-6">
  <div class="max-w-4xl mx-auto">
    <h1 class="text-3xl font-bold mb-4 text-center">üß† Admin v2.1 ‚Äî Face Sync Dashboard (Smart + Fast)</h1>

    <!-- Control panel -->
    <div class="bg-slate-800 rounded-xl p-5 mb-4 shadow">
      <div class="flex flex-col md:flex-row md:items-center md:justify-between gap-4">
        <div>
          <p id="status" class="text-gray-300">‚è≥ Loading models...</p>
          <p id="lastSync" class="text-gray-400 text-sm mt-1">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏ã‡∏¥‡∏á‡∏Ñ‡πå</p>
        </div>

        <div class="flex gap-2 items-center">
          <label class="text-sm text-gray-300 mr-2">MIN FACE (px)</label>
          <input id="minFaceSize" type="number" value="50" min="20" max="1000" class="w-24 px-2 py-1 rounded bg-slate-700 text-white"/>
          <label class="ml-4 text-sm text-gray-300">Auto Sync</label>
          <input id="autoSyncToggle" type="checkbox" class="h-5 w-5 ml-2" />
          <label class="ml-2 text-sm text-gray-300">Interval (s)</label>
          <input id="autoInterval" type="number" value="60" min="10" step="5" class="w-20 px-2 py-1 rounded bg-slate-700 text-white ml-2"/>
        </div>
      </div>

      <div class="mt-4 flex flex-wrap gap-2">
        <button id="syncNow" class="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded">üîÅ Sync Now</button>
        <button id="stopAuto" class="bg-yellow-600 hover:bg-yellow-700 px-4 py-2 rounded">‚è∏Ô∏è Stop Auto</button>
        <button id="clearLog" class="bg-red-600 hover:bg-red-700 px-4 py-2 rounded">üßπ Clear Log</button>
        <button id="clearCache" class="bg-gray-600 hover:bg-gray-700 px-4 py-2 rounded">üóëÔ∏è Clear Cache</button>
      </div>
    </div>

    <!-- Progress / Stats -->
    <div class="bg-slate-800 rounded-xl p-5 mb-4 shadow">
      <div class="mb-3">
        <div class="flex justify-between">
          <div class="text-sm text-gray-300">Processed: <span id="processed">0</span>/<span id="total">0</span></div>
          <div class="text-sm text-gray-300">Elapsed: <span id="elapsed">0s</span></div>
        </div>
        <div class="w-full bg-slate-700 rounded h-4 mt-2 overflow-hidden">
          <div id="progressBar" class="h-4 bg-green-500 w-0 transition-all"></div>
        </div>
      </div>

      <div class="grid grid-cols-3 gap-3 text-center">
        <div class="bg-slate-700 p-3 rounded">
          <div class="text-sm text-gray-300">‚úÖ Success</div>
          <div id="countSuccess" class="text-2xl font-bold text-green-400">0</div>
        </div>
        <div class="bg-slate-700 p-3 rounded">
          <div class="text-sm text-gray-300">‚öôÔ∏è Skipped</div>
          <div id="countSkipped" class="text-2xl font-bold text-blue-300">0</div>
        </div>
        <div class="bg-slate-700 p-3 rounded">
          <div class="text-sm text-gray-300">‚ùå Failed</div>
          <div id="countFailed" class="text-2xl font-bold text-red-400">0</div>
        </div>
      </div>
    </div>

    <!-- Log -->
    <div class="bg-slate-800 rounded-xl p-4 shadow mb-6">
      <h2 class="text-lg font-semibold mb-2">üìú Log</h2>
      <div id="log" class="h-72 overflow-y-auto bg-slate-900/30 p-3 rounded text-xs font-mono"></div>
    </div>

    <!-- Footer / Help -->
    <div class="text-sm text-gray-400">
      <p>‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏: ‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏∞‡∏Ç‡πâ‡∏≤‡∏°‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏†‡∏≤‡∏û‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥ (jpg, jpeg, png, webp, gif) ‡πÅ‡∏•‡∏∞‡∏Ç‡πâ‡∏≤‡∏° `.emptyFolderPlaceholder`</p>
      <p class="mt-1">‡∏´‡∏≤‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏¢‡∏≠‡∏°‡∏£‡∏±‡∏ö‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏•‡πá‡∏Å ‡πÉ‡∏´‡πâ‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡πà‡∏≤ MIN FACE ‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡πà‡∏≤‡∏ï‡πà‡∏≥‡∏•‡∏á (‡πÄ‡∏ä‡πà‡∏ô 40 ‡∏´‡∏£‡∏∑‡∏≠ 30)</p>
      <p class="mt-1">‚ú® ‡∏£‡∏∞‡∏ö‡∏ö‡∏ô‡∏µ‡πâ‡πÉ‡∏ä‡πâ Local Cache ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏£‡πà‡∏á‡∏Å‡∏≤‡∏£‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ï‡πà‡∏≠‡πÑ‡∏õ (Incremental Sync)</p>
    </div>
  </div>

  <script type="module">
    import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm'

    // -------------------------
    // CONFIG
    // -------------------------
    const SUPABASE_URL = "https://xjdjurdflowiwdxgkvfr.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InhqZGp1cmRmbG93aXdkeGdrdmZyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQzMDk5OTEsImV4cCI6MjA2OTg4NTk5MX0.QtWt1IrY1UYKmj0spL3T8CkaQh9wq2P-_4b6eWB3ics";
    const BUCKET = "gallery";
    const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    // -------------------------
    // DOM
    // -------------------------
    const statusEl = document.getElementById('status');
    const lastSyncEl = document.getElementById('lastSync');
    const syncNowBtn = document.getElementById('syncNow');
    const stopAutoBtn = document.getElementById('stopAuto');
    const clearLogBtn = document.getElementById('clearLog');
    const clearCacheBtn = document.getElementById('clearCache');
    const logEl = document.getElementById('log');
    const processedEl = document.getElementById('processed');
    const totalEl = document.getElementById('total');
    const progressBar = document.getElementById('progressBar');
    const elapsedEl = document.getElementById('elapsed');
    const minFaceSizeInput = document.getElementById('minFaceSize');
    const autoSyncToggle = document.getElementById('autoSyncToggle');
    const autoIntervalInput = document.getElementById('autoInterval');
    const countSuccessEl = document.getElementById('countSuccess');
    const countSkippedEl = document.getElementById('countSkipped');
    const countFailedEl = document.getElementById('countFailed');

    let isSyncing = false;
    let stopRequested = false;
    let autoSyncId = null;
    let stats = { success: 0, skipped: 0, failed: 0, processed: 0, total: 0 };
    let startTime = null;

    // -------------------------
    // CACHE HELPERS
    // -------------------------
    function loadCache() {
      return JSON.parse(localStorage.getItem('gallery-cache') || '{}');
    }
    function saveCache(cache) {
      localStorage.setItem('gallery-cache', JSON.stringify(cache));
    }
    function clearCache() {
      localStorage.removeItem('gallery-cache');
      log('info', 'üóëÔ∏è ‡∏•‡πâ‡∏≤‡∏á cache ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢');
    }

    // -------------------------
    // LOG / UI HELPERS
    // -------------------------
    function log(type, text) {
      const time = new Date().toLocaleTimeString();
      const color = type === 'error' ? 'text-red-300' : type === 'warn' ? 'text-yellow-300' : 'text-green-300';
      const p = document.createElement('div');
      p.className = `${color} mb-1`;
      p.innerHTML = `<span class="text-gray-400">[${time}]</span> ${text}`;
      logEl.prepend(p);
    }

    function resetStats() {
      stats = { success: 0, skipped: 0, failed: 0, processed: 0, total: 0 };
      updateStatsUI();
    }

    function updateStatsUI() {
      countSuccessEl.textContent = stats.success;
      countSkippedEl.textContent = stats.skipped;
      countFailedEl.textContent = stats.failed;
      processedEl.textContent = stats.processed;
      totalEl.textContent = stats.total;
      const pct = stats.total ? Math.round((stats.processed / stats.total) * 100) : 0;
      progressBar.style.width = pct + '%';
    }

    function updateElapsed() {
      if (!startTime) { elapsedEl.textContent = '0s'; return; }
      const s = Math.floor((Date.now() - startTime) / 1000);
      elapsedEl.textContent = s + 's';
    }

    // -------------------------
    // FACE-API
    // -------------------------
    async function loadModels() {
      statusEl.textContent = '‚è≥ ‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏• face-api...';
      const modelURL = 'https://cdn.jsdelivr.net/npm/@vladmandic/face-api@1.7.4/model/';
      await Promise.all([
        faceapi.nets.ssdMobilenetv1.loadFromUri(modelURL),
        faceapi.nets.faceLandmark68Net.loadFromUri(modelURL),
        faceapi.nets.faceRecognitionNet.loadFromUri(modelURL)
      ]);
      statusEl.textContent = '‚úÖ ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏ã‡∏¥‡∏á‡∏Ñ‡πå';
      log('info', '‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô');
    }

    // -------------------------
    // STORAGE LIST (recursive)
    // -------------------------
    async function listRecursive(path = '', map = {}) {
      const { data, error } = await supabase.storage.from(BUCKET).list(path, { limit: 1000 });
      if (error) {
        log('error', `Storage list error: ${error.message}`);
        return map;
      }
      for (const item of data) {
        if (!item.metadata) {
          if (item.name && item.name.startsWith('.')) continue;
          await listRecursive(path ? `${path}/${item.name}` : item.name, map);
        } else {
          const fullPath = path ? `${path}/${item.name}` : item.name;
          map[fullPath] = { updated_at: item.updated_at };
        }
      }
      return map;
    }

    function normalize(desc) {
      const norm = Math.sqrt(desc.reduce((a,b)=>a+b*b,0));
      return desc.map(x => x / norm);
    }

    function isImagePath(path) {
      if (!path) return false;
      if (path.includes('.emptyFolderPlaceholder')) return false;
      return !!path.match(/\.(jpg|jpeg|png|webp|gif)$/i);
    }

    async function insertFace(name, image_url, embedding) {
      const { error } = await supabase.rpc('insert_face_vector', {
        p_name: name, p_image_url: image_url, p_embedding: embedding
      });
      return error ? { ok: false, error } : { ok: true };
    }

    // -------------------------
    // MAIN SYNC (with cache)
    // -------------------------
    async function syncGallery() {
      if (isSyncing) return log('warn', '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß');
      stopRequested = false;
      isSyncing = true;
      resetStats();
      startTime = Date.now();
      updateElapsed();
      statusEl.textContent = 'üîÑ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ã‡∏¥‡∏á‡∏Ñ‡πå...';

      try {
        const allFilesMap = await listRecursive('');
        const allFiles = Object.keys(allFilesMap).filter(isImagePath);
        const cache = loadCache();

        stats.total = allFiles.length;
        updateStatsUI();
        if (stats.total === 0) {
          log('warn', '‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏†‡∏≤‡∏û‡πÉ‡∏ô bucket');
          statusEl.textContent = '‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏†‡∏≤‡∏û';
          isSyncing = false;
          return;
        }

        log('info', `‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏• ${stats.total} ‡πÑ‡∏ü‡∏•‡πå`);

        for (const path of allFiles) {
          if (stopRequested) { log('warn', '‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡πÇ‡∏î‡∏¢‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ'); break; }
          updateElapsed();

          const cacheTimestamp = cache[path];
          const updatedAt = allFilesMap[path].updated_at;

          if (cacheTimestamp && updatedAt <= cacheTimestamp) {
            stats.skipped++; stats.processed++;
            log('info', `‚è≠Ô∏è ‡∏Ç‡πâ‡∏≤‡∏° (cache): ${path}`);
            updateStatsUI();
            continue;
          }

          try {
            const { data: exists } = await supabase.from('faces').select('id').eq('image_url', path).maybeSingle();
            if (exists) {
              stats.skipped++; stats.processed++; updateStatsUI();
              cache[path] = updatedAt; saveCache(cache);
              log('info', `‡∏Ç‡πâ‡∏≤‡∏° (‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß): ${path}`);
              continue;
            }

            const imgUrl = `${SUPABASE_URL}/storage/v1/object/public/${BUCKET}/${encodeURIComponent(path)}`;
            let img;
            try {
              img = await faceapi.fetchImage(imgUrl);
            } catch (e) {
              log('error', `fetchImage failed: ${path} - ${e.message}`);
              stats.failed++; stats.processed++; updateStatsUI();
              continue;
            }

            const det = await faceapi.detectSingleFace(img).withFaceLandmarks().withFaceDescriptor();
            if (!det) {
              stats.failed++; stats.processed++; updateStatsUI();
              log('warn', `‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤: ${path}`);
              continue;
            }

            const minFace = Number(minFaceSizeInput.value) || 50;
            if (det.detection.box.width < minFace || det.detection.box.height < minFace) {
              stats.failed++; stats.processed++; updateStatsUI();
              log('warn', `‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏•‡πá‡∏Å‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ: ${path}`);
              continue;
            }

            const embedding = normalize(Array.from(det.descriptor));
            const name = path.split('/').pop().split('.').shift();

            const res = await insertFace(name, path, embedding);
            if (!res.ok) {
              stats.failed++; stats.processed++; updateStatsUI();
              log('error', `‚ùå Error ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å ${path}: ${res.error.message}`);
            } else {
              stats.success++; stats.processed++; updateStatsUI();
              cache[path] = updatedAt; saveCache(cache);
              log('info', `‚úÖ ‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: ${path}`);
            }

          } catch (err) {
            stats.failed++; stats.processed++; updateStatsUI();
            log('error', `Exception ${path}: ${err.message}`);
          }
        }

        const now = new Date().toLocaleString();
        lastSyncEl.textContent = `‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î: ${now}`;
        statusEl.textContent = `‚úÖ ‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡πÄ‡∏™‡∏£‡πá‡∏à (‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ${stats.success}, ‡∏Ç‡πâ‡∏≤‡∏° ${stats.skipped}, ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß ${stats.failed})`;
        log('info', `‡∏™‡∏£‡∏∏‡∏õ: ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ${stats.success}, ‡∏Ç‡πâ‡∏≤‡∏° ${stats.skipped}, ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß ${stats.failed}`);

      } catch (err) {
        log('error', `Critical sync error: ${err.message}`);
        statusEl.textContent = '‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ã‡∏¥‡∏á‡∏Ñ‡πå';
      } finally {
        isSyncing = false;
      }
    }

    // -------------------------
    // AUTO SYNC CONTROL
    // -------------------------
    function startAutoSync() {
      stopAuto();
      const intervalSec = Math.max(10, Number(autoIntervalInput.value) || 60);
      autoSyncId = setInterval(() => {
        if (!isSyncing) syncGallery();
      }, intervalSec * 1000);
      autoSyncToggle.checked = true;
      log('info', `Auto Sync ‡πÄ‡∏£‡∏¥‡πà‡∏° (‡∏ó‡∏∏‡∏Å ${intervalSec}s)`);
    }
    function stopAuto() {
      if (autoSyncId) clearInterval(autoSyncId);
      autoSyncId = null;
      autoSyncToggle.checked = false;
      log('info', 'Auto Sync ‡∏´‡∏¢‡∏∏‡∏î‡πÅ‡∏•‡πâ‡∏ß');
    }

    // -------------------------
    // EVENTS
    // -------------------------
    syncNowBtn.addEventListener('click', syncGallery);
    stopAutoBtn.addEventListener('click', () => { stopRequested = true; stopAuto(); });
    clearLogBtn.addEventListener('click', () => { logEl.innerHTML = ''; resetStats(); });
    clearCacheBtn.addEventListener('click', clearCache);
    autoSyncToggle.addEventListener('change', e => e.target.checked ? startAutoSync() : stopAuto());

    // -------------------------
    // INIT
    // -------------------------
    window.addEventListener('DOMContentLoaded', async () => {
      await loadModels();
      if (autoSyncToggle.checked) startAutoSync();
      setInterval(updateElapsed, 1000);
    });
  </script>
</body>
</

