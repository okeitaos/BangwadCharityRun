<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Face Search | ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏†‡∏≤‡∏û‡∏î‡πâ‡∏ß‡∏¢‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://cdn.jsdelivr.net/npm/@vladmandic/face-api@1.7.4/dist/face-api.min.js"></script>

  <style>
    .filename {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      display: block;
      width: 100%;
      text-align: center;
    }

    #previewPopup {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 50;
      overflow-y: auto;
      padding: 2rem 1rem;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.35s ease;
    }

    #previewPopup.show {
      opacity: 1;
      pointer-events: auto;
    }

    #previewPopup > div {
      background: #1e293b;
      border-radius: 1rem;
      box-shadow: 0 0 25px rgba(0, 0, 0, 0.7);
      text-align: center;
      max-width: 600px;
      width: 100%;
      margin: auto;
      transform: translateY(20px);
      transition: transform 0.35s ease;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    #previewPopup.show > div {
      transform: translateY(0);
    }

    #previewCanvas {
      max-width: 100%;
      max-height: 75vh;
      object-fit: contain;
      border: 2px solid white;
      border-radius: 0.75rem;
      margin-bottom: 1rem;
      display: block;
      margin-left: auto;
      margin-right: auto;
    }

    #confirmDownload, #cancelPreview {
      transition: transform 0.15s ease, background 0.25s;
    }

    #confirmDownload:hover, #cancelPreview:hover {
      transform: scale(1.05);
    }

    @media (max-width: 640px) {
      #previewPopup > div {
        width: 95%;
        padding: 1rem;
      }
      #previewCanvas {
        max-height: 60vh;
      }
    }
  </style>
</head>

<body class="bg-slate-900 text-white flex flex-col items-center min-h-screen p-6">
  <div class="w-full max-w-md">
    <div class="flex justify-between items-center mb-4">
      <h1 id="title" class="text-2xl font-bold">üì∏ ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏†‡∏≤‡∏û‡∏î‡πâ‡∏ß‡∏¢‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤</h1>
      <button id="langToggle" class="bg-blue-600 hover:bg-blue-700 px-3 py-1 rounded text-sm">EN</button>
    </div>

    <div class="bg-slate-800 p-6 rounded-xl shadow-lg text-center">
      <input id="fileInput" type="file" accept="image/*" class="mb-4 w-full text-gray-300" />

      <!-- üÜï Multi-face toggle -->
      <label class="flex items-center gap-2 mb-4 justify-center text-sm text-gray-300">
        <input type="checkbox" id="multiFace" class="h-4 w-4">
        ‡∏ï‡∏£‡∏ß‡∏à‡∏´‡∏•‡∏≤‡∏¢‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡πÉ‡∏ô‡∏†‡∏≤‡∏û
      </label>

      <div class="flex gap-2 mb-4">
        <button id="searchBtn" class="flex-1 bg-green-500 hover:bg-green-600 py-2 rounded-lg">
          üîé <span id="btnSearchText">‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏†‡∏≤‡∏û</span>
        </button>
        <button id="clearBtn" class="bg-red-500 hover:bg-red-600 px-4 py-2 rounded-lg">
          üßπ <span id="btnClearText">‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå</span>
        </button>
      </div>

      <div class="mb-4 text-left">
        <label for="threshold" id="thresholdLabel" class="block text-sm text-gray-300 mb-1">
          ‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô (95%)
        </label>
        <input id="threshold" type="range" min="80" max="99" value="95" class="w-full accent-green-500">
        <p id="thresholdValue" class="text-xs text-gray-400 mt-1 text-center">‚â• 95%</p>
      </div>

      <p id="status" class="text-gray-400 text-sm mb-3">‚è≥ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏•...</p>
      <div id="result" class="text-sm text-gray-200"></div>
    </div>
  </div>

  <!-- üñºÔ∏è Popup Preview -->
  <div id="previewPopup">
    <div class="bg-slate-800 p-4 rounded-xl shadow-xl text-center max-w-lg w-[90%]">
      <h2 class="text-lg font-semibold mb-3">üñºÔ∏è Preview ‡∏Å‡πà‡∏≠‡∏ô‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î</h2>
      <canvas id="previewCanvas" class="max-w-full rounded-lg shadow-lg border-2 border-white mb-3"></canvas>
      <div class="flex justify-center gap-3">
        <button id="confirmDownload" class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg">
          ‚úÖ ‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î
        </button>
        <button id="cancelPreview" class="bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded-lg">
          ‚ùå ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å
        </button>
      </div>
    </div>
  </div>

  <script type="module">
/* ===========================================================
   üî• FULL SCRIPT ‚Äî FACE SYNC v2.9.1
   üî• All old functions kept exactly the same
   üî• Added: Multi-face detection, safe image loader,
            smart fallback, face-area integrity check,
            URL encoder, improved robustness
   =========================================================== */

import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm";

const SUPABASE_URL = "https://xjdjurdflowiwdxgkvfr.supabase.co";
const SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InhqZGp1cmRmbG93aXdkeGdrdmZyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQzMDk5OTEsImV4cCI6MjA2OTg4NTk5MX0.QtWt1IrY1UYKmj0spL3T8CkaQh9wq2P-_4b6eWB3ics";
const BUCKET = "gallery";
const supabase = createClient(SUPABASE_URL, SUPABASE_KEY);

const $ = id => document.getElementById(id);
const delay = ms => new Promise(r => setTimeout(r, ms));

/* ===========================================================
   üÜï SAFE IMAGE LOADER (‡πÅ‡∏Å‡πâ bufferToImage error)
   =========================================================== */
async function loadImageSafe(url) {
  try {
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error("Fetch failed");
    const blob = await res.blob();
    return await faceapi.bufferToImage(blob);
  } catch (err) {
    throw new Error("‡πÇ‡∏´‡∏•‡∏î‡∏£‡∏π‡∏õ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ: " + err.message);
  }
}

/* ===========================================================
   üÜï MULTI-FACE DETECTION (‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏∏‡∏Å‡πÉ‡∏ö‡πÉ‡∏ô‡∏†‡∏≤‡∏û)
   =========================================================== */
async function detectFacesAll(img) {
  const optsSSD = new faceapi.SsdMobilenetv1Options({ minConfidence: 0.3 });
  const optsTiny = new faceapi.TinyFaceDetectorOptions({
    inputSize: 832,
    scoreThreshold: 0.25
  });

  let detections = await faceapi
    .detectAllFaces(img, optsSSD)
    .withFaceLandmarks()
    .withFaceDescriptors();

  if (detections.length === 0) {
    detections = await faceapi
      .detectAllFaces(img, optsTiny)
      .withFaceLandmarks()
      .withFaceDescriptors();
  }

  return detections;
}

/* ===========================================================
   üî• LOG SYSTEM (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏Ç‡∏≠‡∏á‡πÄ‡∏î‡∏¥‡∏° ‚Äî ‡πÑ‡∏°‡πà‡∏•‡∏ö)
   =========================================================== */
const log = (type, text) => {
  const time = new Date().toLocaleTimeString();
  const color =
    type === "error" ? "text-red-300" :
    type === "warn" ? "text-yellow-300" : "text-green-300";

  const div = document.createElement("div");
  div.className = `${color} mb-1`;
  div.innerHTML = `<span class="text-gray-400">[${time}]</span> ${text}`;
  $("log").prepend(div);
};

/* ===========================================================
   üìä STATS SYSTEM (‡∏Ç‡∏≠‡∏á‡πÄ‡∏î‡∏¥‡∏°)
   =========================================================== */
let isSyncing = false;
let stopRequested = false;
let startTime = null;
let autoSyncId = null;

let stats = { success: 0, skipped: 0, failed: 0, processed: 0, total: 0 };
const processedSet = new Set();
const failedImages = new Map();

const updateStats = () => {
  $("countSuccess").textContent = stats.success;
  $("countSkipped").textContent = stats.skipped;
  $("countFailed").textContent = stats.failed;
  $("processed").textContent = stats.processed;
  $("total").textContent = stats.total;

  const pct = stats.total ? (stats.processed / stats.total) * 100 : 0;
  $("progressBar").style.width = pct + "%";
};

/* ===========================================================
   üìÅ CACHE SYSTEM (‡∏Ç‡∏≠‡∏á‡πÄ‡∏î‡∏¥‡∏°)
   =========================================================== */
const loadCache = () => JSON.parse(localStorage.getItem("gallery-cache") || "{}");
const saveCache = c => localStorage.setItem("gallery-cache", JSON.stringify(c));
const clearCache = () => {
  localStorage.removeItem("gallery-cache");
  log("info", "üßπ ‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå Cache ‡πÅ‡∏•‡πâ‡∏ß");
};

/* ===========================================================
   üß† ‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏• FaceAPI ‚Äî (‡∏Ç‡∏≠‡∏á‡πÄ‡∏î‡∏¥‡∏° + ‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏´‡∏°‡πà‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏Ç‡∏∂‡πâ‡∏ô)
   =========================================================== */
async function loadModels() {
  $("status").textContent = "‚è≥ ‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏•...";
  const url = "https://cdn.jsdelivr.net/npm/@vladmandic/face-api@1.7.4/model/";
  
  await Promise.all([
    faceapi.nets.ssdMobilenetv1.loadFromUri(url),
    faceapi.nets.tinyFaceDetector.loadFromUri(url),
    faceapi.nets.faceLandmark68Net.loadFromUri(url),
    faceapi.nets.faceRecognitionNet.loadFromUri(url)
  ]);

  $("status").textContent = "‚úÖ ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏ã‡∏¥‡∏á‡∏Ñ‡πå";
  log("info", "‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à");
}

/* ===========================================================
   üß™ ‡∏Å‡∏≤‡∏£ Sync (MAIN CORE)
   ‚Äî ‡πÄ‡∏û‡∏¥‡πà‡∏° detectFacesAll (multi-face)
   ‚Äî ‡∏õ‡∏£‡∏±‡∏ö fallback loader
   =========================================================== */
async function handleSync(path, map, cache, attempt = 0, retrySingle = false) {
  const updated = map[path].updated_at;
  if (!retrySingle && cache[path] && updated <= cache[path]) {
    if (!processedSet.has(path)) {
      stats.skipped++;
      processedSet.add(path);
      stats.processed++;
      updateStats();
    }
    return;
  }

  try {
    // ====== ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏°‡∏µ‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏•‡πâ‡∏ß? ======
    const { data: exists } = await supabase
      .from("faces")
      .select("id")
      .eq("image_url", path)
      .maybeSingle();

    if (exists) {
      stats.skipped++;
      processedSet.add(path);
      stats.processed++;
      cache[path] = updated;
      saveCache(cache);
      updateStats();
      return;
    }

    // ====== ‡πÇ‡∏´‡∏•‡∏î‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢ ======
    const encodedPath = encodeURIComponent(path);
    const url = `${SUPABASE_URL}/storage/v1/object/public/${BUCKET}/${encodedPath}`;
    const img = await loadImageSafe(url);

    // ====== ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏´‡∏•‡∏≤‡∏¢‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤ ======
    const detections = await detectFacesAll(img);
    if (!detections || detections.length === 0) {
      throw new Error("‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡πÉ‡∏ô‡∏†‡∏≤‡∏û");
    }

    // ====== ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà‡πÉ‡∏´‡∏ç‡πà‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î (‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏™‡∏∏‡∏î) ======
    const mainFace = detections.sort((a, b) =>
      b.detection.box.width * b.detection.box.height -
      a.detection.box.width * a.detection.box.height
    )[0];

    const minFace = Number($("minFaceSize").value) || 60;
    if (
      mainFace.detection.box.width < minFace ||
      mainFace.detection.box.height < minFace
    ) {
      throw new Error("‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏•‡πá‡∏Å‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ");
    }

    const emb = Array.from(mainFace.descriptor);
    const name = path.split("/").pop().split(".").shift();

    // ====== ‡∏™‡πà‡∏á‡πÄ‡∏Ç‡πâ‡∏≤ Supabase RPC ======
    const { error } = await supabase.rpc("insert_face_vector", {
      p_name: name,
      p_image_url: path,
      p_embedding: emb
    });
    if (error) throw new Error(error.message);

    stats.success++;
    cache[path] = updated;
    saveCache(cache);
    log("info", `‚úÖ ${path}`);

  } catch (err) {
    if (attempt < 2 && !retrySingle) {
      log("warn", `Retry ${attempt + 1}/3: ${path} (${err.message})`);
      await delay(350);
      return await handleSync(path, map, cache, attempt + 1);
    }

    stats.failed++;
    log("error", `‚ùå ${path}: ${err.message}`);

    const url = `${SUPABASE_URL}/storage/v1/object/public/${BUCKET}/${encodeURIComponent(path)}`;
    addFailedPreview(path, url, err.message);

  } finally {
    if (!processedSet.has(path)) {
      processedSet.add(path);
      stats.processed++;
      updateStats();
    }
  }
}

/* ===========================================================
   ‚ùå PREVIEW FAILED
   =========================================================== */
function addFailedPreview(path, imgUrl, reason) {
  if (failedImages.has(path)) return;
  failedImages.set(path, true);

  const div = document.createElement("div");
  div.className = "bg-slate-700 p-2 rounded relative";
  div.innerHTML = `
    <img src="${imgUrl}" class="rounded w-full object-cover h-40"/>
    <p class="text-xs text-center mt-1 text-red-300">${reason}</p>
    <button class="absolute bottom-2 right-2 bg-blue-600 text-xs px-2 py-1 rounded retry-btn">Retry</button>
  `;
  $("failedGrid").appendChild(div);

  div.querySelector(".retry-btn").onclick = async () => {
    div.style.opacity = 0.5;
    await handleSync(path, { [path]: { updated_at: new Date().toISOString() } }, loadCache(), 0, true);
    div.remove();
    failedImages.delete(path);
  };
}

/* ===========================================================
   üìÅ RECURSIVE LIST (‡∏Ç‡∏≠‡∏á‡πÄ‡∏î‡∏¥‡∏°)
   =========================================================== */
async function listRecursive(path = "", map = {}) {
  const limit = 1000;
  let offset = 0;

  while (true) {
    const { data, error } = await supabase.storage.from(BUCKET).list(path, { limit, offset });
    if (error) break;
    if (!data || data.length === 0) break;

    for (const item of data) {
      if (!item.metadata) {
        if (!item.name.startsWith(".")) {
          await listRecursive(path ? `${path}/${item.name}` : item.name, map);
        }
      } else {
        const full = path ? `${path}/${item.name}` : item.name;
        map[full] = { updated_at: item.updated_at };
      }
    }
    if (data.length < limit) break;
    offset += limit;
    await delay(80);
  }

  return map;
}

/* ===========================================================
   üöÄ MAIN SYNC FUNCTION
   =========================================================== */
async function syncGallery() {
  if (isSyncing) return log("warn", "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏≠‡∏¢‡∏π‡πà");

  isSyncing = true;
  stopRequested = false;
  startTime = Date.now();
  stats = { success: 0, skipped: 0, failed: 0, processed: 0, total: 0 };
  processedSet.clear();
  updateStats();
  $("failedGrid").innerHTML = "";
  $("status").textContent = "üîÑ ‡πÄ‡∏£‡∏¥‡πà‡∏° Sync...";

  try {
    const map = await listRecursive("");
    const files = Object.keys(map).filter(f => f.match(/\.(jpg|jpeg|png|webp)$/i));
    const cache = loadCache();

    stats.total = files.length;
    updateStats();

    const workerCount = Number($("rateLimit").value) || 5;
    const delayMs = Number($("delayMs").value) || 200;

    await Promise.all(
      Array.from({ length: workerCount }, async (_, w) => {
        for (let i = w; i < files.length; i += workerCount) {
          if (stopRequested) break;
          await handleSync(files[i], map, cache);
          if (delayMs) await delay(delayMs);
        }
      })
    );

    $("status").textContent =
      `‚úÖ ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô ‚Äî ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: ${stats.success}, ‡∏Ç‡πâ‡∏≤‡∏°: ${stats.skipped}, ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß: ${stats.failed}`;
    $("lastSync").textContent = "‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î: " + new Date().toLocaleString();

  } catch (e) {
    log("error", "Critical: " + e.message);
  }

  isSyncing = false;
}

/* ===========================================================
   üîò BUTTONS
   =========================================================== */
if ($("syncNow")) $("syncNow").onclick = syncGallery;
if ($("stopAuto")) $("stopAuto").onclick = () => { stopRequested = true; log("warn", "‚è∏Ô∏è ‡∏´‡∏¢‡∏∏‡∏î Sync ‡πÅ‡∏•‡πâ‡∏ß"); };
if ($("clearLog")) $("clearLog").onclick = () => { $("log").innerHTML = ""; stats = { success: 0, skipped: 0, failed: 0, processed: 0, total: 0 }; updateStats(); };
if ($("clearCache")) $("clearCache").onclick = clearCache;
if ($("autoSyncToggle"))
  $("autoSyncToggle").onchange = (e) => {
    if (e.target.checked) {
      const secs = Number($("autoInterval")?.value) || 60;
      autoSyncId = setInterval(syncGallery, secs * 1000);
    } else {
      clearInterval(autoSyncId);
    }
  };

$("stopAuto").onclick = () => {
  stopRequested = true;
  log("warn", "‚è∏Ô∏è ‡∏´‡∏¢‡∏∏‡∏î Sync ‡πÅ‡∏•‡πâ‡∏ß");
};
$("clearLog").onclick = () => {
  $("log").innerHTML = "";
  stats = { success: 0, skipped: 0, failed: 0, processed: 0, total: 0 };
  updateStats();
};
$("clearCache").onclick = clearCache;

/* ===========================================================
   AUTO INTERVAL
   =========================================================== */
$("autoSyncToggle").onchange = e => {
  if (e.target.checked) {
    const secs = Number($("autoInterval").value) || 60;
    autoSyncId = setInterval(syncGallery, secs * 1000);
  } else clearInterval(autoSyncId);
};

/* ===========================================================
   INIT
   =========================================================== */
window.addEventListener("DOMContentLoaded", async () => {
  await loadModels();
  setInterval(() => {
    if (startTime) $("elapsed").textContent = Math.floor((Date.now() - startTime) / 1000) + "s";
  }, 1000);
});
</script>


</body>
</html>
