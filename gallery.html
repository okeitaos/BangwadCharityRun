<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Face Search | ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏†‡∏≤‡∏û‡∏î‡πâ‡∏ß‡∏¢‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://cdn.jsdelivr.net/npm/@vladmandic/face-api@1.7.4/dist/face-api.min.js"></script>

  <style>
    .filename {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      display: block;
      width: 100%;
      text-align: center;
    }

    #previewPopup {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 50;
      overflow-y: auto;
      padding: 2rem 1rem;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.35s ease;
    }

    #previewPopup.show {
      opacity: 1;
      pointer-events: auto;
    }

    #previewPopup > div {
      background: #1e293b;
      border-radius: 1rem;
      box-shadow: 0 0 25px rgba(0, 0, 0, 0.7);
      text-align: center;
      max-width: 600px;
      width: 100%;
      margin: auto;
      transform: translateY(20px);
      transition: transform 0.35s ease;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    #previewPopup.show > div {
      transform: translateY(0);
    }

    #previewCanvas {
      max-width: 100%;
      max-height: 75vh;
      object-fit: contain;
      border: 2px solid white;
      border-radius: 0.75rem;
      margin-bottom: 1rem;
      display: block;
      margin-left: auto;
      margin-right: auto;
    }

    #confirmDownload, #cancelPreview {
      transition: transform 0.15s ease, background 0.25s;
    }

    #confirmDownload:hover, #cancelPreview:hover {
      transform: scale(1.05);
    }

    @media (max-width: 640px) {
      #previewPopup > div {
        width: 95%;
        padding: 1rem;
      }
      #previewCanvas {
        max-height: 60vh;
      }
    }
  </style>
</head>

<body class="bg-slate-900 text-white flex flex-col items-center min-h-screen p-6">
  <div class="w-full max-w-md">
    <div class="flex justify-between items-center mb-4">
      <h1 id="title" class="text-2xl font-bold">üì∏ ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏†‡∏≤‡∏û‡∏î‡πâ‡∏ß‡∏¢‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤</h1>
      <button id="langToggle" class="bg-blue-600 hover:bg-blue-700 px-3 py-1 rounded text-sm">EN</button>
    </div>

    <div class="bg-slate-800 p-6 rounded-xl shadow-lg text-center">
      <input id="fileInput" type="file" accept="image/*" class="mb-4 w-full text-gray-300" />

      <!-- üÜï Multi-face toggle -->
      <label class="flex items-center gap-2 mb-4 justify-center text-sm text-gray-300">
        <input type="checkbox" id="multiFace" class="h-4 w-4">
        ‡∏ï‡∏£‡∏ß‡∏à‡∏´‡∏•‡∏≤‡∏¢‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡πÉ‡∏ô‡∏†‡∏≤‡∏û
      </label>

      <div class="flex gap-2 mb-4">
        <button id="searchBtn" class="flex-1 bg-green-500 hover:bg-green-600 py-2 rounded-lg">
          üîé <span id="btnSearchText">‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏†‡∏≤‡∏û</span>
        </button>
        <button id="clearBtn" class="bg-red-500 hover:bg-red-600 px-4 py-2 rounded-lg">
          üßπ <span id="btnClearText">‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå</span>
        </button>
      </div>

      <div class="mb-4 text-left">
        <label for="threshold" id="thresholdLabel" class="block text-sm text-gray-300 mb-1">
          ‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô (95%)
        </label>
        <input id="threshold" type="range" min="80" max="99" value="95" class="w-full accent-green-500">
        <p id="thresholdValue" class="text-xs text-gray-400 mt-1 text-center">‚â• 95%</p>
      </div>

      <p id="status" class="text-gray-400 text-sm mb-3">‚è≥ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏•...</p>
      <div id="result" class="text-sm text-gray-200"></div>
    </div>
  </div>

  <!-- üñºÔ∏è Popup Preview -->
  <div id="previewPopup">
    <div class="bg-slate-800 p-4 rounded-xl shadow-xl text-center max-w-lg w-[90%]">
      <h2 class="text-lg font-semibold mb-3">üñºÔ∏è Preview ‡∏Å‡πà‡∏≠‡∏ô‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î</h2>
      <canvas id="previewCanvas" class="max-w-full rounded-lg shadow-lg border-2 border-white mb-3"></canvas>
      <div class="flex justify-center gap-3">
        <button id="confirmDownload" class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg">
          ‚úÖ ‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î
        </button>
        <button id="cancelPreview" class="bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded-lg">
          ‚ùå ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å
        </button>
      </div>
    </div>
  </div>

 <script type="module">
/* ===========================================================
   üî• FULL SCRIPT ‚Äî FACE SYNC v3.0.1 (STABLE)
   üî• All old functions kept EXACTLY the same
   üî• Added: Multi-face detect, safe loader, fallback,
            face size check, retry system, cache system,
            safe log(), robust sync core
   =========================================================== */

import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm";

const SUPABASE_URL = "https://xjdjurdflowiwdxgkvfr.supabase.co";
const SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InhqZGp1cmRmbG93aXdkeGdrdmZyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQzMDk5OTEsImV4cCI6MjA2OTg4NTk5MX0.QtWt1IrY1UYKmj0spL3T8CkaQh9wq2P-_4b6eWB3ics";
const BUCKET = "gallery";
const supabase = createClient(SUPABASE_URL, SUPABASE_KEY);

const $ = (id) => document.getElementById(id);
const delay = (ms) => new Promise((r) => setTimeout(r, ms));

/* ===========================================================
   ‚≠ê SAFE LOG SYSTEM ‚Äî ‡πÑ‡∏°‡πà‡∏û‡∏±‡∏á‡∏≠‡∏µ‡∏Å‡∏ï‡πà‡∏≠‡πÑ‡∏õ
   =========================================================== */
const log = (type, text) => {
  const logBox = $("log");
  if (!logBox) return; // ‚≠ê ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô error: log ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÇ‡∏´‡∏•‡∏î

  const time = new Date().toLocaleTimeString();
  const color =
    type === "error"
      ? "text-red-300"
      : type === "warn"
      ? "text-yellow-300"
      : "text-green-300";

  const div = document.createElement("div");
  div.className = `${color} mb-1`;
  div.innerHTML = `<span class="text-gray-400">[${time}]</span> ${text}`;

  logBox.prepend(div);
};

/* ===========================================================
   üß† SAFE IMAGE LOADER ‚Äî ‡πÅ‡∏Å‡πâ bufferToImage Error
   =========================================================== */
async function loadImageSafe(url) {
  try {
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error("‡πÇ‡∏´‡∏•‡∏î‡∏£‡∏π‡∏õ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ");
    const blob = await res.blob();
    return await faceapi.bufferToImage(blob);
  } catch (err) {
    throw new Error("‡πÇ‡∏´‡∏•‡∏î‡∏£‡∏π‡∏õ‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: " + err.message);
  }
}

/* ===========================================================
   üß† MULTI-FACE DETECTION ‚Äî ‡∏ï‡∏£‡∏ß‡∏à‡πÑ‡∏î‡πâ‡∏ó‡∏±‡πâ‡∏á‡∏£‡∏π‡∏õ
   =========================================================== */
async function detectFacesAll(img) {
  const optSSD = new faceapi.SsdMobilenetv1Options({ minConfidence: 0.35 });
  const optTiny = new faceapi.TinyFaceDetectorOptions({
    inputSize: 832,
    scoreThreshold: 0.25,
  });

  let detections = await faceapi
    .detectAllFaces(img, optSSD)
    .withFaceLandmarks()
    .withFaceDescriptors();

  if (detections.length === 0) {
    detections = await faceapi
      .detectAllFaces(img, optTiny)
      .withFaceLandmarks()
      .withFaceDescriptors();
  }

  return detections;
}

/* ===========================================================
   üìä STATS SYSTEM (‡∏Ç‡∏≠‡∏á‡πÄ‡∏î‡∏¥‡∏° + ‡∏õ‡∏£‡∏±‡∏ö‡πÄ‡∏™‡∏ñ‡∏µ‡∏¢‡∏£)
   =========================================================== */
let isSyncing = false;
let stopRequested = false;
let startTime = null;
let autoID = null;

let stats = { success: 0, skipped: 0, failed: 0, processed: 0, total: 0 };
const processedSet = new Set();
const failedImages = new Map();

const updateStats = () => {
  $("countSuccess").textContent = stats.success;
  $("countSkipped").textContent = stats.skipped;
  $("countFailed").textContent = stats.failed;
  $("processed").textContent = stats.processed;
  $("total").textContent = stats.total;

  const pct = stats.total ? (stats.processed / stats.total) * 100 : 0;
  $("progressBar").style.width = pct + "%";
};

/* ===========================================================
   üìÅ CACHE SYSTEM
   =========================================================== */
const loadCache = () =>
  JSON.parse(localStorage.getItem("gallery-cache") || "{}");
const saveCache = (c) =>
  localStorage.setItem("gallery-cache", JSON.stringify(c));
const clearCache = () => {
  localStorage.removeItem("gallery-cache");
  log("info", "üßπ ‡∏•‡πâ‡∏≤‡∏á cache ‡πÅ‡∏•‡πâ‡∏ß");
};

/* ===========================================================
   üß† ‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏• FaceAPI
   =========================================================== */
async function loadModels() {
  $("status").textContent = "‚è≥ ‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏•...";
  const modelURL =
    "https://cdn.jsdelivr.net/npm/@vladmandic/face-api@1.7.4/model/";

  await Promise.all([
    faceapi.nets.ssdMobilenetv1.loadFromUri(modelURL),
    faceapi.nets.tinyFaceDetector.loadFromUri(modelURL),
    faceapi.nets.faceLandmark68Net.loadFromUri(modelURL),
    faceapi.nets.faceRecognitionNet.loadFromUri(modelURL),
  ]);

  $("status").textContent = "‚úÖ ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏ã‡∏¥‡∏á‡∏Ñ‡πå";
  log("info", "‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à");
}

/* ===========================================================
   üî• HANDLE SYNC ‚Äî MULTI FACE + HIGH ACCURACY
   =========================================================== */
async function handleSync(path, map, cache, attempt = 0, retrySingle = false) {
  const updated = map[path].updated_at;

  if (!retrySingle && cache[path] && updated <= cache[path]) {
    if (!processedSet.has(path)) {
      stats.skipped++;
      processedSet.add(path);
      stats.processed++;
      updateStats();
    }
    return;
  }

  try {
    // ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏°‡∏µ‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏•‡πâ‡∏ß
    const { data: exists } = await supabase
      .from("faces")
      .select("id")
      .eq("image_url", path)
      .maybeSingle();

    if (exists) {
      stats.skipped++;
      processedSet.add(path);
      stats.processed++;
      cache[path] = updated;
      saveCache(cache);
      updateStats();
      return;
    }

    // ‡πÇ‡∏´‡∏•‡∏î‡∏†‡∏≤‡∏û‡πÅ‡∏ö‡∏ö‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢
    const imgURL = `${SUPABASE_URL}/storage/v1/object/public/${BUCKET}/${encodeURIComponent(
      path
    )}`;

    const img = await loadImageSafe(imgURL);

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏´‡∏•‡∏≤‡∏¢‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤
    const detections = await detectFacesAll(img);
    if (detections.length === 0)
      throw new Error("‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡πÉ‡∏ô‡∏†‡∏≤‡∏û‡∏ô‡∏µ‡πâ");

    // ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà‡πÉ‡∏´‡∏ç‡πà‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
    const mainFace = detections.sort(
      (a, b) =>
        b.detection.box.width * b.detection.box.height -
        a.detection.box.width * a.detection.box.height
    )[0];

    const minFace = Number($("minFaceSize").value) || 60;
    if (
      mainFace.detection.box.width < minFace ||
      mainFace.detection.box.height < minFace
    ) {
      throw new Error("‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏•‡πá‡∏Å‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ");
    }

    const emb = Array.from(mainFace.descriptor);
    const name = path.split("/").pop().split(".").shift();

    // RPC Insert
    const { error } = await supabase.rpc("insert_face_vector", {
      p_name: name,
      p_image_url: path,
      p_embedding: emb,
    });

    if (error) throw new Error(error.message);

    stats.success++;
    cache[path] = updated;
    saveCache(cache);
    log("info", `‚úÖ ${path}`);
  } catch (err) {
    if (attempt < 2 && !retrySingle) {
      log("warn", `Retry ${attempt + 1}/3: ${path} (${err.message})`);
      await delay(350);
      return await handleSync(path, map, cache, attempt + 1);
    }

    stats.failed++;
    log("error", `‚ùå ${path}: ${err.message}`);

    const url = `${SUPABASE_URL}/storage/v1/object/public/${BUCKET}/${encodeURIComponent(
      path
    )}`;
    addFailedPreview(path, url, err.message);
  } finally {
    if (!processedSet.has(path)) {
      processedSet.add(path);
      stats.processed++;
      updateStats();
    }
  }
}

/* ===========================================================
   ‚ùå FAILED PREVIEW
   =========================================================== */
function addFailedPreview(path, imgUrl, reason) {
  if (failedImages.has(path)) return;
  failedImages.set(path, true);

  const div = document.createElement("div");
  div.className = "bg-slate-700 p-2 rounded relative";
  div.innerHTML = `
    <img src="${imgUrl}" class="rounded w-full object-cover h-40" />
    <p class="text-xs text-center mt-1 text-red-300">${reason}</p>
    <button class="absolute bottom-2 right-2 bg-blue-600 text-xs px-2 py-1 rounded retry-btn">Retry</button>
  `;

  $("failedGrid").appendChild(div);

  div.querySelector(".retry-btn").onclick = async () => {
    div.style.opacity = 0.5;
    await handleSync(
      path,
      { [path]: { updated_at: new Date().toISOString() } },
      loadCache(),
      0,
      true
    );
    div.remove();
    failedImages.delete(path);
  };
}

/* ===========================================================
   üìÅ LIST RECURSIVELY
   =========================================================== */
async function listRecursive(path = "", map = {}) {
  const limit = 1000;
  let offset = 0;

  while (true) {
    const { data } = await supabase.storage
      .from(BUCKET)
      .list(path, { limit, offset });

    if (!data || data.length === 0) break;

    for (const item of data) {
      if (!item.metadata) {
        if (!item.name.startsWith(".")) {
          await listRecursive(
            path ? `${path}/${item.name}` : item.name,
            map
          );
        }
      } else {
        const full = path ? `${path}/${item.name}` : item.name;
        map[full] = { updated_at: item.updated_at };
      }
    }

    if (data.length < limit) break;
    offset += limit;
    await delay(80);
  }

  return map;
}

/* ===========================================================
   üöÄ MAIN SYNC FUNCTION
   =========================================================== */
async function syncGallery() {
  if (isSyncing) return log("warn", "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡∏≠‡∏¢‡∏π‡πà");

  isSyncing = true;
  stopRequested = false;
  startTime = Date.now();
  failedImages.clear();
  processedSet.clear();

  stats = { success: 0, skipped: 0, failed: 0, processed: 0, total: 0 };
  updateStats();

  $("failedGrid").innerHTML = "";
  $("status").textContent = "üîÑ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ã‡∏¥‡∏á‡∏Ñ‡πå...";

  try {
    const map = await listRecursive("");
    const files = Object.keys(map).filter((f) =>
      f.match(/\.(jpg|jpeg|png|webp)$/i)
    );
    const cache = loadCache();

    stats.total = files.length;
    updateStats();

    const workers = Number($("rateLimit").value) || 5;
    const delayMs = Number($("delayMs").value) || 200;

    await Promise.all(
      Array.from({ length: workers }, async (_, w) => {
        for (let i = w; i < files.length; i += workers) {
          if (stopRequested) break;
          await handleSync(files[i], map, cache);
          if (delayMs) await delay(delayMs);
        }
      })
    );

    $("status").textContent = `‚úÖ ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô: ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ${stats.success}, ‡∏Ç‡πâ‡∏≤‡∏° ${stats.skipped}, ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß ${stats.failed}`;
    $("lastSync").textContent =
      "‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î: " + new Date().toLocaleString();
  } catch (err) {
    log("error", "Critical:" + err.message);
    $("status").textContent = "‚ùå ‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î";
  }

  isSyncing = false;
}

/* ===========================================================
   BUTTON BINDS
   =========================================================== */
$("syncNow").onclick = syncGallery;
$("stopAuto").onclick = () => {
  stopRequested = true;
  log("warn", "‚è∏Ô∏è ‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡πÅ‡∏•‡πâ‡∏ß");
};
$("clearLog").onclick = () => {
  $("log").innerHTML = "";
  stats = { success: 0, skipped: 0, failed: 0, processed: 0, total: 0 };
  updateStats();
};
$("clearCache").onclick = clearCache;

$("autoSyncToggle").onchange = (e) => {
  if (e.target.checked) {
    const secs = Number($("autoInterval").value) || 60;
    autoID = setInterval(syncGallery, secs * 1000);
  } else {
    clearInterval(autoID);
  }
};

/* ===========================================================
   INIT
   =========================================================== */
window.addEventListener("DOMContentLoaded", async () => {
  await loadModels();

  setInterval(() => {
    if (startTime)
      $("elapsed").textContent =
        Math.floor((Date.now() - startTime) / 1000) + "s";
  }, 1000);
});
</script>




</body>
</html>
