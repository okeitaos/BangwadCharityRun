<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>üîç ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏£‡∏π‡∏õ‡∏î‡πâ‡∏ß‡∏¢‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤ (IndexedDB Cache)</title>

<!-- Supabase client -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<!-- Face API -->
<script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Prompt:wght@400;600&display=swap" rel="stylesheet">

<style>
  body{font-family:"Prompt",sans-serif;margin:0;background:#0f172a;color:#fff;text-align:center;padding:20px}
  h1{color:#facc15}
  #uploadInput{margin:12px;padding:10px;border-radius:14px;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.12)}
  #status{color:#facc15;margin:8px;font-weight:600}
  .progress{width:80%;max-width:900px;margin:14px auto;background:rgba(255,255,255,0.06);height:18px;border-radius:9px;overflow:hidden}
  .bar{height:100%;width:0%;background:linear-gradient(90deg,#22c55e,#84cc16);transition:width .2s}
  .controls{margin:12px}
  button{margin:6px;padding:8px 14px;border-radius:12px;border:none;cursor:pointer}
  .btn{background:#06C755;color:#fff}
  .btn-muted{background:#334155;color:#fff}
  .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:12px;max-width:1100px;margin:18px auto}
  .card{background:rgba(255,255,255,0.04);border-radius:12px;overflow:hidden;box-shadow:0 4px 14px rgba(0,0,0,0.4)}
  .card img{width:100%;height:180px;object-fit:cover}
  .card p{margin:8px;color:#eee}
  small{opacity:.75}
  #cacheInfo{margin-top:8px;color:#cbd5e1}
</style>
</head>
<body>
  <h1>üîç ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏£‡∏π‡∏õ‡∏î‡πâ‡∏ß‡∏¢‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤ (‡∏°‡∏µ Cache)</h1>
  <p>‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏Å‡πá‡∏ö descriptor ‡∏•‡∏á IndexedDB ‚Äî ‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏Å‡∏±‡∏ö‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏´‡∏•‡∏≤‡∏¢‡∏£‡πâ‡∏≠‡∏¢‡∏ñ‡∏∂‡∏á‡∏û‡∏±‡∏ô‡∏£‡∏π‡∏õ</p>

  <input id="uploadInput" type="file" accept="image/*">
  <div id="status">‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏•‡πÅ‡∏•‡∏∞‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•... ‡πÇ‡∏õ‡∏£‡∏î‡∏£‡∏≠‡∏™‡∏±‡∏Å‡∏Ñ‡∏£‡∏π‡πà</div>

  <div class="progress"><div id="bar" class="bar"></div></div>

  <div class="controls">
    <button id="btnClear" class="btn-muted">‡∏•‡πâ‡∏≤‡∏á Cache</button>
    <button id="btnReindex" class="btn">‡∏£‡∏µ‡∏Ñ‡∏≤‡∏•‡∏Ñ‡∏π‡πÄ‡∏•‡∏ï‡∏ó‡∏µ‡πà‡∏¢‡∏±‡∏á‡∏Ç‡∏≤‡∏î</button>
    <span id="cacheInfo"></span>
  </div>

  <div id="resultGrid" class="grid"></div>

<script>
/* ============ CONFIG ============ */
/* ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏Ñ‡πà‡∏≤ SUPABASE_KEY ‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì */
const SUPABASE_URL = "https://xjdjurdflowiwdxgkvfr.supabase.co";
const SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InhqZGp1cmRmbG93aXdkeGdrdmZyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQzMDk5OTEsImV4cCI6MjA2OTg4NTk5MX0.QtWt1IrY1UYKmj0spL3T8CkaQh9wq2P-_4b6eWB3ics";// <-- ‡πÅ‡∏Å‡πâ‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ
const BUCKET = "gallery";
const sb = supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

/* MODEL URL (‡πÉ‡∏ä‡πâ vladmandic model CDN) */
const MODEL_URL = "https://cdn.jsdelivr.net/gh/vladmandic/face-api/model/";

/* Cache DB settings */
const DB_NAME = "face-cache";
const DB_STORE = "descriptors";
/* batch size ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á descriptor ‡∏ó‡∏µ‡∏•‡∏∞‡∏ä‡∏∏‡∏î */
const BATCH_SIZE = 30;

/* ============ IndexedDB helper (‡πÄ‡∏•‡πá‡∏Å‡πÜ) ============ */
function openDb() {
  return new Promise((res, rej) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = e => {
      const db = e.target.result;
      if (!db.objectStoreNames.contains(DB_STORE)) {
        db.createObjectStore(DB_STORE, { keyPath: "url" });
      }
    };
    req.onsuccess = e => res(e.target.result);
    req.onerror = e => rej(e.target.error);
  });
}
async function idbGetAll() {
  const db = await openDb();
  return new Promise((res, rej) => {
    const tx = db.transaction(DB_STORE, "readonly");
    const store = tx.objectStore(DB_STORE);
    const req = store.getAll();
    req.onsuccess = () => res(req.result);
    req.onerror = () => rej(req.error);
  });
}
async function idbPut(item) {
  const db = await openDb();
  return new Promise((res, rej) => {
    const tx = db.transaction(DB_STORE, "readwrite");
    const store = tx.objectStore(DB_STORE);
    const req = store.put(item);
    req.onsuccess = () => res(true);
    req.onerror = () => rej(req.error);
  });
}
async function idbClear() {
  const db = await openDb();
  return new Promise((res, rej) => {
    const tx = db.transaction(DB_STORE, "readwrite");
    const store = tx.objectStore(DB_STORE);
    const req = store.clear();
    req.onsuccess = () => res(true);
    req.onerror = () => rej(req.error);
  });
}

/* ============ face-api init & utility ============ */
let modelsLoaded = false;
async function loadModels() {
  const s = document.getElementById("status");
  s.innerText = "‚è≥ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏• face-api (‡πÄ‡∏ö‡∏≤)...";
  await faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL);
  await faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL);
  await faceapi.nets.faceRecognitionNet.loadFromUri(MODEL_URL);
  modelsLoaded = true;
  s.innerText = "‚úÖ ‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô";
}

/* Euclidean distance */
function euclid(a, b) {
  let sum = 0.0;
  for (let i = 0; i < a.length; i++) {
    const d = a[i] - b[i];
    sum += d * d;
  }
  return Math.sqrt(sum);
}

/* fetch image and descriptor */
async function descriptorFromUrl(url) {
  const img = await faceapi.fetchImage(url);
  const det = await faceapi
    .detectSingleFace(img, new faceapi.TinyFaceDetectorOptions())
    .withFaceLandmarks()
    .withFaceDescriptor();
  return det ? Array.from(det.descriptor) : null;
}

/* descriptor from file (search image) */
async function descriptorFromFile(file) {
  const img = await faceapi.bufferToImage(file);
  const det = await faceapi
    .detectSingleFace(img, new faceapi.TinyFaceDetectorOptions())
    .withFaceLandmarks()
    .withFaceDescriptor();
  return det ? Array.from(det.descriptor) : null;
}

/* ============ Load list of images from Supabase ============ */
/* NOTE:
   ‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÑ‡∏ü‡∏•‡πå‡∏Ç‡∏≠‡∏á user ‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô list(...) ‡πÄ‡∏õ‡πá‡∏ô sb.storage.from(BUCKET).list(`${userId}/`) */
async function listAllImages() {
  const foldersResult = await sb.storage.from(BUCKET).list("", { limit: 100 });
  const images = [];
  for (const folder of foldersResult.data || []) {
    if (!folder.name || folder.name.startsWith(".")) continue;
    const filesResult = await sb.storage.from(BUCKET).list(folder.name + "/", { limit: 10000 });
    for (const f of filesResult.data || []) {
      if (/\.(jpe?g|png)$/i.test(f.name)) {
        images.push({
          url: `${SUPABASE_URL}/storage/v1/object/public/${BUCKET}/${folder.name}/${f.name}`,
          name: f.name,
          folder: folder.name
        });
      }
    }
  }
  return images;
}

/* ============ Main cache & indexing logic ============ */
async function ensureCacheIndexed(allImages) {
  const status = document.getElementById("status");
  const bar = document.getElementById("bar");

  // read cache
  const cached = await idbGetAll();
  const cachedMap = new Map(cached.map(c => [c.url, c]));
  // find missing
  const missing = allImages.filter(img => !cachedMap.has(img.url));

  if (missing.length === 0) {
    status.innerText = `‚úÖ Cache ‡∏û‡∏£‡πâ‡∏≠‡∏° (${cached.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£)`;
    updateCacheInfo();
    return cached; // return cached entries
  }

  status.innerText = `‚è≥ ‡∏™‡∏£‡πâ‡∏≤‡∏á descriptor ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö ${missing.length} ‡∏£‡∏π‡∏õ ‚Äî ‡πÇ‡∏õ‡∏£‡∏î‡∏£‡∏≠...`;
  let processed = 0;
  for (let i = 0; i < missing.length; i += BATCH_SIZE) {
    const batch = missing.slice(i, i + BATCH_SIZE);
    await Promise.all(batch.map(async (img) => {
      try {
        const desc = await descriptorFromUrl(img.url);
        if (desc) {
          await idbPut({ url: img.url, name: img.name, folder: img.folder, descriptor: desc });
        } else {
          // mark as no-face to avoid repeated work
          await idbPut({ url: img.url, name: img.name, folder: img.folder, descriptor: null, noface: true });
        }
      } catch (err) {
        console.warn("skip:", img.url, err);
        // don't block; store as noface to avoid retry loop
        try { await idbPut({ url: img.url, name: img.name, folder: img.folder, descriptor: null, noface: true }); } catch {}
      }
    }));
    processed += batch.length;
    const pct = Math.round((processed / missing.length) * 100);
    bar.style.width = pct + "%";
    status.innerText = `üîé ‡∏™‡∏£‡πâ‡∏≤‡∏á descriptor: ${processed}/${missing.length} (${pct}%)`;
    // yield to UI
    await new Promise(r => setTimeout(r, 80));
  }

  bar.style.width = "0%";
  status.innerText = `‚úÖ ‡∏™‡∏£‡πâ‡∏≤‡∏á descriptor ‡πÄ‡∏™‡∏£‡πá‡∏à (${missing.length} ‡πÉ‡∏´‡∏°‡πà)`;
  updateCacheInfo();
  return await idbGetAll();
}

/* ============ Search flow ============ */
async function onSearchFile(file) {
  const status = document.getElementById("status");
  const bar = document.getElementById("bar");
  const resultGrid = document.getElementById("resultGrid");

  if (!modelsLoaded) { alert("‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏¢‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏°‡πà‡πÄ‡∏™‡∏£‡πá‡∏à"); return; }
  status.innerText = "üîç ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏°‡∏≤...";
  const queryDesc = await descriptorFromFile(file);
  if (!queryDesc) { status.innerText = "‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡πÉ‡∏ô‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á"; return; }

  // load cached descriptors
  const cache = await idbGetAll();
  const valid = cache.filter(c => Array.isArray(c.descriptor) && c.descriptor.length > 0);
  if (valid.length === 0) {
    status.innerText = "‚ö†Ô∏è ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ descriptor ‡πÉ‡∏ô‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á (‡∏ï‡πâ‡∏≠‡∏á‡∏ó‡∏≥ reindex ‡∏´‡∏£‡∏∑‡∏≠‡πÉ‡∏ä‡πâ‡∏´‡∏ô‡πâ‡∏≤ upload ‡πÄ‡∏û‡∏∑‡πà‡∏≠ index)";
    return;
  }

  status.innerText = `üîé ‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö‡∏Å‡∏±‡∏ö ${valid.length} descriptor...`;
  // compute distances in chunked manner
  const results = [];
  const chunk = 300; // ‡πÅ‡∏ö‡πà‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏ä‡∏∏‡∏î‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ block UI
  for (let i = 0; i < valid.length; i += chunk) {
    const part = valid.slice(i, i + chunk);
    for (const item of part) {
      const d = euclid(queryDesc, item.descriptor);
      // threshold ‡∏õ‡∏£‡∏±‡∏ö‡πÑ‡∏î‡πâ (0.4-0.7) ‚Äî ‡∏Ñ‡πà‡∏≤‡∏ô‡πâ‡∏≠‡∏¢=‡πÉ‡∏Å‡∏•‡πâ‡∏Å‡∏ß‡πà‡∏≤
      if (d < 0.6) results.push({ url: item.url, name: item.name, folder: item.folder, distance: d });
    }
    bar.style.width = Math.min(Math.round(((i + chunk) / valid.length) * 100), 100) + "%";
    await new Promise(r => setTimeout(r, 12));
  }
  bar.style.width = "0%";

  if (results.length === 0) {
    status.innerText = "üò¢ ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡∏Ñ‡∏•‡πâ‡∏≤‡∏¢‡∏Å‡∏±‡∏ô";
    resultGrid.innerHTML = "";
    return;
  }

  results.sort((a,b)=> a.distance - b.distance);
  status.innerText = `‚úÖ ‡∏û‡∏ö ${results.length} ‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡∏Ñ‡∏•‡πâ‡∏≤‡∏¢‡∏Å‡∏±‡∏ô (‡πÅ‡∏™‡∏î‡∏á top 50)`;
  renderResults(results.slice(0,50));
}

/* ============ UI render ============ */
function renderResults(list) {
  const grid = document.getElementById("resultGrid");
  grid.innerHTML = list.map(i=>`
    <div class="card">
      <img src="${i.url}" alt="${i.name}">
      <p>${i.name} <br><small>‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á: ${i.distance.toFixed(3)}</small></p>
    </div>
  `).join("");
}

async function updateCacheInfo() {
  const all = await idbGetAll();
  const totalIndexed = all.filter(a=>Array.isArray(a.descriptor) && a.descriptor.length>0).length;
  document.getElementById("cacheInfo").innerText = `Cache: ${totalIndexed} descriptors / ${all.length} files (IndexedDB)`;
}

/* ============ Buttons ============ */
document.getElementById("uploadInput").addEventListener("change", async (e)=>{
  const file = e.target.files[0];
  if (!file) return;
  await onSearchFile(file);
});

document.getElementById("btnClear").addEventListener("click", async ()=>{
  if (!confirm("‡∏•‡πâ‡∏≤‡∏á cache ‡∏ö‡∏ô‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á (IndexedDB) ‡πÉ‡∏ä‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?")) return;
  await idbClear();
  updateCacheInfo();
  document.getElementById("status").innerText = "üóëÔ∏è Cache ‡∏ñ‡∏π‡∏Å‡∏•‡πâ‡∏≤‡∏á‡πÅ‡∏•‡πâ‡∏ß";
});

document.getElementById("btnReindex").addEventListener("click", async ()=>{
  document.getElementById("status").innerText = "üîÅ ‡πÄ‡∏£‡∏¥‡πà‡∏° reindex ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î (‡∏î‡∏π progress bar)...";
  const allImages = await listAllImages();
  await ensureCacheIndexed(allImages);
  document.getElementById("status").innerText = "‚úÖ Reindex ‡πÄ‡∏™‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß";
});

/* ============ Startup sequence ============ */
(async function init(){
  try {
    await loadModels();
    // ‡πÇ‡∏´‡∏•‡∏î list ‡∏£‡∏π‡∏õ (‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì descriptor ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÇ‡∏î‡∏¢‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥)
    const images = await listAllImages();
    // ‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ ‡πÉ‡∏´‡πâ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì descriptor ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÅ‡∏£‡∏Å (‡∏ñ‡πâ‡∏£‡∏π‡∏õ‡πÑ‡∏°‡πà‡∏°‡∏≤‡∏Å)
    // ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡∏£‡∏∞‡∏´‡∏¢‡∏±‡∏î‡πÄ‡∏ß‡∏•‡∏≤ ‡πÉ‡∏´‡πâ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏Å‡∏î "‡∏£‡∏µ‡∏Ñ‡∏≤‡∏•‡∏Ñ‡∏π‡πÄ‡∏•‡∏ï" ‡πÄ‡∏≠‡∏á
    document.getElementById("status").innerText = `‡∏û‡∏ö ${images.length} ‡πÑ‡∏ü‡∏•‡πå‡πÉ‡∏ô bucket. ‡∏Å‡∏î "‡∏£‡∏µ‡∏Ñ‡∏≤‡∏•‡∏Ñ‡∏π‡πÄ‡∏•‡∏ï" ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏™‡∏£‡πâ‡∏≤‡∏á descriptor ‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÇ‡∏î‡∏¢‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡∏£‡∏π‡∏õ‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô.`;
    await updateCacheInfo();
    // store images list in memory for later reindex use
    window._allImagesList = images;
  } catch (err) {
    console.error(err);
    document.getElementById("status").innerText = "‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏Ç‡∏ì‡∏∞‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô: " + (err.message||err);
  }
})();
</script>
</body>
</html>
